#version 460 core
#extension GL_ARB_shading_language_include : require
#include "/basic_shapes.comp" //! #include "./basic_shapes.comp"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;



uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_pos;
uniform int rng_seed;
uniform int reset = 0; // -1: reseting, 0: reseted, 1: have to reset
uniform int samples;

const float hitThreshold = 0.001;
const float farPlane = 1000.0;
const int max_bounces = 4;
const float diffusion_angle = 180.0; // in degrees
uniform vec3 light_pos = vec3(-20.0, -20.0, 20.0);
uniform float light_radius = 2.0;


layout (std430, binding = 1) buffer Spheres {
	Sphere[] spheres;
};
uniform int spheres_no;

layout (std430, binding = 2) buffer Cubes {
	Cube[] cubes;
};
uniform int cubes_no;

layout (std430, binding = 3) buffer Cylinders {
	Cylinder[] cylinders;
};
uniform int cylinders_no;

layout (std430, binding = 4) buffer Cones {
	Cone[] cones;
};
uniform int cones_no;


struct RaycastHit {
	bool hit;
	vec3 ray_pos;
	vec3 ray_dir;
	vec4 ray_color;
	vec3 normal;
	int obj_type;
	int obj_index;
};

float signDistBlendedObj(float obj_dist_0, float obj_dist_1, int booleanType = -1, float blend = 0.5) {
	switch(booleanType) {
	case -1:
		return min(obj_dist_0, obj_dist_1);
	case 0:
		return smoothUnion(obj_dist_0, obj_dist_1, blend);
	case 1:
		return smoothIntersect(obj_dist_0, obj_dist_1, blend);
	case 2:
		return smoothDifference(obj_dist_0, obj_dist_1, blend);
	}
}
float signDistObj(vec3 ray_pos, int obj_type, int obj_index) {
	switch(obj_type) {
	case 0:
		return signDistSphere(ray_pos, spheres[obj_index].location, spheres[obj_index].radius);
	case 1:
		return signDistCube(ray_pos, cubes[obj_index].location, cubes[obj_index].dimensions);
	case 2:
		return signDistCylinder(ray_pos, cylinders[obj_index].location, cylinders[obj_index].radius, cylinders[obj_index].height);
	case 3:
		return signDistCone(ray_pos, cones[obj_index].location, cones[obj_index].radius, cones[obj_index].height);
	}
	return -999999999;
}
float signDistScene(vec3 ray_pos) {
	float minDist = 999999999;

	// Check for closest Sphere
	for (int i = 0; i < spheres_no; ++i) {
		if (spheres[i].visible == 0) {
			continue;
		}

		float distToSphere = signDistSphere(ray_pos, spheres[i].location, spheres[i].radius);
		float distToOther = signDistObj(ray_pos, spheres[i].booleanObjType, spheres[i].booleanObjIndex);
		float booleanDist = signDistBlendedObj(distToSphere, distToOther, spheres[i].booleanType);
		float closest = signDistBlendedObj(minDist, booleanDist);

		if (closest < minDist) {
			minDist = closest;
		}
	}
	// Check for closest Cube
	for (int i = 0; i < cubes_no; ++i) {
		if (cubes[i].visible == 0) {
			continue;
		}

		float distToCube = signDistCube(ray_pos, cubes[i].location, cubes[i].dimensions);
		float distToOther = signDistObj(ray_pos, cubes[i].booleanObjType, cubes[i].booleanObjIndex);
		float booleanDist = signDistBlendedObj(distToCube, distToOther, cubes[i].booleanType);
		float closest = signDistBlendedObj(minDist, booleanDist);

		if (closest < minDist) {
			minDist = closest;
		}
	}
	// Check for closest Cylinder
	for (int i = 0; i < cylinders_no; ++i) {
		if (cylinders[i].visible == 0) {
			continue;
		}

		float distToCylinder = signDistCylinder(ray_pos, cylinders[i].location, cylinders[i].radius, cylinders[i].height);
		float distToOther = signDistObj(ray_pos, cylinders[i].booleanObjType, cylinders[i].booleanObjIndex);
		float booleanDist = signDistBlendedObj(distToCylinder, distToOther, cylinders[i].booleanType);
		float closest = signDistBlendedObj(minDist, booleanDist);

		if (closest < minDist) {
			minDist = closest;
		}
	}
	// Check for closest Cone
	for (int i = 0; i < cones_no; ++i) {
		if (cones[i].visible == 0) {
			continue;
		}
		
		float distToCone = signDistCone(ray_pos, cones[i].location, cones[i].radius, cones[i].height);
		float distToOther = signDistObj(ray_pos, cones[i].booleanObjType, cones[i].booleanObjIndex);
		float booleanDist = signDistBlendedObj(distToCone, distToOther, cones[i].booleanType);
		float closest = signDistBlendedObj(minDist, booleanDist);

		if (closest < minDist) {
			minDist = closest;
		}
	}

	return minDist;
}
vec3 normalScene(vec3 ray_pos) {
	const float epsilon = 0.001;
	const mat3x3 d = mat3x3(
		vec3(epsilon, 0, 0),
		vec3(0, epsilon, 0),
		vec3(0, 0, epsilon)
	);

	float cd = signDistScene(ray_pos);
	return normalize((vec3(signDistScene(ray_pos + d[0]), signDistScene(ray_pos + d[1]), signDistScene(ray_pos + d[2])) - cd) / epsilon);
}

RaycastHit raycast(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * hitThreshold * 100.0;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder, 3 - cone
	int obj_index = -1;
	float minimumDistance = 999999999;
	float mDepsDistMin = 0.5;
	float mDepsDistDiff = 0.1;
	int mDeqCount = 0;
	while (distance(init_pos, ray_pos) < farPlane) {
		float minDist = 999999999;

		// Check for closest Sphere
		for (int i = 0; i < spheres_no; ++i) {
			if (spheres[i].visible == 0) {
				continue;
			}

			float distToSphere = signDistSphere(ray_pos, spheres[i].location, spheres[i].radius);
			float distToOther = signDistObj(ray_pos, spheres[i].booleanObjType, spheres[i].booleanObjIndex);
			float booleanDist = signDistBlendedObj(distToSphere, distToOther, spheres[i].booleanType);
			float closest = signDistBlendedObj(minDist, booleanDist);

			if (closest < minDist) {
				minDist = closest;
				obj_type = 0;
				obj_index = i;
			}
		}
		// Check for closest Cube
		for (int i = 0; i < cubes_no; ++i) {
			if (cubes[i].visible == 0) {
				continue;
			}

			float distToCube = signDistCube(ray_pos, cubes[i].location, cubes[i].dimensions);
			float distToOther = signDistObj(ray_pos, cubes[i].booleanObjType, cubes[i].booleanObjIndex);
			float booleanDist = signDistBlendedObj(distToCube, distToOther, cubes[i].booleanType);
			float closest = signDistBlendedObj(minDist, booleanDist);

			if (closest < minDist) {
				minDist = closest;
				obj_type = 1;
				obj_index = i;
			}
		}
		// Check for closest Cylinder
		for (int i = 0; i < cylinders_no; ++i) {
			if (cylinders[i].visible == 0) {
				continue;
			}

			float distToCylinder = signDistCylinder(ray_pos, cylinders[i].location, cylinders[i].radius, cylinders[i].height);
			float distToOther = signDistObj(ray_pos, cylinders[i].booleanObjType, cylinders[i].booleanObjIndex);
			float booleanDist = signDistBlendedObj(distToCylinder, distToOther, cylinders[i].booleanType);
			float closest = signDistBlendedObj(minDist, booleanDist);

			if (closest < minDist) {
				minDist = closest;
				obj_type = 2;
				obj_index = i;
			}
		}
		// Check for closest Cone
		for (int i = 0; i < cones_no; ++i) {
			if (cones[i].visible == 0) {
				continue;
			}

			float distToCone = signDistCone(ray_pos, cones[i].location, cones[i].radius, cones[i].height);
			float distToOther = signDistObj(ray_pos, cones[i].booleanObjType, cones[i].booleanObjIndex);
			float booleanDist = signDistBlendedObj(distToCone, distToOther, cones[i].booleanType);
			float closest = signDistBlendedObj(minDist, booleanDist);

			if (closest < minDist) {
				minDist = closest;
				obj_type = 3;
				obj_index = i;
			}
		}
		
		//float normalScale = max(0.5, abs(dot(normalScene(ray_pos), ray_dir)));
		//ray_pos += ray_dir * max(minDist, minDist / normalScale);
		if (distance(minimumDistance, minDist) < mDepsDistDiff && minDist < mDepsDistMin) {
			minDist *= pow(2, mDeqCount + 1);
			mDeqCount++;
		} else {
			minimumDistance = minDist;
			mDeqCount = 0;
		}
		ray_pos += ray_dir * minDist;

		if (minDist < hitThreshold) {
			/*
			vec3 normal =
				  obj_type == 0 ? normalSphere(ray_pos, spheres[obj_index].location, spheres[obj_index].radius)
				: obj_type == 1 ? normalCube(ray_pos, cubes[obj_index].location, cubes[obj_index].dimensions)
				: obj_type == 2 ? normalCylinder(ray_pos, cylinders[obj_index].location, cylinders[obj_index].radius, cylinders[obj_index].height)
				: obj_type == 3 ? normalCone(ray_pos, cones[obj_index].location, cones[obj_index].radius, cones[obj_index].height)
				: vec3(0.0)
			;
			*/
			vec4 color =
				  obj_type == 0 ? spheres[obj_index].color
				: obj_type == 1 ? cubes[obj_index].color
				: obj_type == 2 ? cylinders[obj_index].color
				: obj_type == 3 ? cones[obj_index].color
				: vec4(1.0)
			;
			return RaycastHit(true, ray_pos, ray_dir, color, normalScene(ray_pos), obj_type, obj_index);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec4(0.0), vec3(0.0), -1, -1);
}
RaycastHit raycast_light(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * hitThreshold * 100.0;

	while (distance(init_pos, ray_pos) < farPlane) {
		float minDist = 999999999;
		float temp = min(minDist, signDistSphere(ray_pos, light_pos, light_radius));
		if (temp < minDist) {
			minDist = temp;
		}
		ray_pos += ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal = normalSphere(ray_pos, light_pos, light_radius);
			return RaycastHit(true, ray_pos, ray_dir, vec4(1.0), normal, -1, -1);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec4(0.0), vec3(0.0), -1, -1);
}

RaycastHit reflectHit(in RaycastHit hit) {
	return RaycastHit(
		hit.hit,
		hit.ray_pos,
		normalize(reflect(normalize(hit.ray_dir), normalize(hit.normal))),
		hit.ray_color,
		hit.normal,
		hit.obj_type,
		hit.obj_index
	);
}



float randomAngle(ivec2 pixel_coords, float max_angle) {
	return (max_angle + mod(pixel_coords.x * pixel_coords.y + rng_seed, max_angle)) / 2.0;
}

vec3 brdfMicrofacet(vec3 light_dir, vec3 view_dir, vec3 normal, vec3 color, float mettalic, float roughness, float reflectance) {
	vec3 halflv = normalize(light_dir + view_dir);

	float NoV = clamp(dot(normal,   view_dir),  0.0, 1.0);
	float NoL = clamp(dot(normal,   light_dir), 0.0, 1.0);
	float NoH = clamp(dot(normal,   halflv),    0.0, 1.0);
	float VoH = clamp(dot(view_dir, halflv),    0.0, 1.0);

	vec3 F0 = vec3(0.16 * reflectance * reflectance);
	F0 = mix(F0, color, mettalic);

	vec3 F = fresnelSchlick(VoH, F0);
	float D = D_GGX(NoH, roughness);
	float G = G_Smith(NoV, NoL, roughness);

	vec3 spec = (F * D * G) / (4.0 * max(NoV, 0.001) * max(NoL, 0.001));

	vec3 rhoD = color;
	rhoD *= vec3(1.0) - F;
	rhoD *= 1.0 - mettalic;
	vec3 diff = rhoD * rpi;

	return diff + spec;
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));

	if (reset == -1) {
		imageStore(img_output, pixel_coords, vec4(0.0, 0.0, 0.0, 1.0));
		return;
	}


	int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = 1.0 - (pixel_coords.x * 2.0) / imageSize(img_output).x;
	float ndcY = 1.0 - (pixel_coords.y * 2.0) / imageSize(img_output).y;

	vec4 ndcPoint = vec4(ndcX, ndcY, -1.0, 1.0);

	vec4 worldPoint = inverse(camera_proj * camera_view) * ndcPoint;
	worldPoint /= worldPoint.w;

	vec3 ray_loc = camera_pos;
	vec3 ray_dir = normalize(worldPoint.xyz - camera_pos);
	vec3 ray_color = vec3(0.0);


	RaycastHit hit = raycast(ray_loc, ray_dir);
	RaycastHit init_hit = hit;
	if (hit.hit == true) {
		ray_color = hit.ray_color.xyz;
		int bounces = max_bounces;
		float dist = 0.0;
		float light_intensity = 100.0;

		while (bounces > 0) {
			// Shadows
			//float randomAngle = ((diffusion_angle + rng_seed / diffusion_angle) / 2.0 + mod(pixel_coords.x * pixel_coords.y, diffusion_angle)) / 2.0;
			float shadowAngle = randomAngle(pixel_coords, diffusion_angle / 4.0);
			vec3 light_dir = diffuseVector(reflectHit(hit).ray_dir, hit.normal, shadowAngle);
			RaycastHit light_hit = raycast_light(hit.ray_pos, light_dir);
			if (light_hit.hit == true) {
				RaycastHit shadow_hit = raycast(hit.ray_pos, light_dir);
				if (shadow_hit.hit == true) {
					if (hit.obj_type == shadow_hit.obj_type
					&& hit.obj_index == shadow_hit.obj_index) {
						ray_color *= 0.0;
					} else if (distance(hit.ray_pos, shadow_hit.ray_pos) < distance(hit.ray_pos, light_pos)) {
						ray_color *= 0.0;
					}
				}
			} else {
				ray_color *= 0.0;
			}


			// Diffuse Light
			float diffuseAngle = randomAngle(pixel_coords, diffusion_angle);
			vec3 new_dir = diffuseVector(reflectHit(hit).ray_dir, hit.normal, diffuseAngle);
			RaycastHit last_hit = hit;
			hit = raycast(hit.ray_pos, new_dir);
			if (hit.hit == false) {
				break;
			}

			dist += distance(last_hit.ray_pos, hit.ray_pos);
			//float light_energy = light_intensity / (distance(light_pos, hit.ray_pos) + dist);
			//ray_color += hit.ray_color.xyz * light_energy;
			/*
			ray_color += brdfMicrofacet(
				normalize(light_pos - hit.ray_pos),
				-ray_dir,
				hit.normal,
				hit.ray_color.xyz,
				0.0,
				0.1,
				0.5
			);
			*/
			ray_color += hit.ray_color.xyz * (bounces == max_bounces ? 1.0 : 0.0);

			bounces--;
		}
	}
	// Reflections
	RaycastHit refl_hit = raycast(init_hit.ray_pos, reflectHit(init_hit).ray_dir);
	float fresnel = pow(1.0 - abs(dot(ray_dir, init_hit.normal)), 2.0);
	if (refl_hit.hit == true) {
		//ray_color = mulAdd(ray_color, refl_hit.ray_color.xyz * fresnel);
	}

	// Final Color
	ray_color = max(ray_color, 0.0);



	vec3 currect_pixel = max(vec3(imageLoad(img_output, pixel_coords)), 0.0);
	vec4 final_color = vec4((currect_pixel + ray_color), 1.0);
	final_color.a = 1.0;
	if (reset == 1) {
		imageStore(img_output, pixel_coords, vec4(ray_color * samples, 1.0));
	}
	else if (reset == 0) {
		imageStore(img_output, pixel_coords, final_color);
	}
}
