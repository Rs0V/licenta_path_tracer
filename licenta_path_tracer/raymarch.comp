#version 460 core
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;


uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_pos;
uniform int rng_seed;

const float hitThreshold = 0.001;
const float farPlane = 1000.0;
const int max_bounces = 5;
const float diffusion_angle = 80.0; // in degrees
const vec3 light_pos = vec3(-20.0, -20.0, 20.0);


struct Sphere {
	vec3 location;
	float radius;
};
layout (std430, binding = 1) buffer Spheres {
	Sphere[] spheres;
};
uniform int spheres_no;

struct Cube {
	vec3 location;
	vec3 dimensions;
};
layout (std430, binding = 2) buffer Cubes {
	Cube[] cubes;
};
uniform int cubes_no;

struct Cylinder {
	vec3 location;
	float radius;
	float height;
};
layout (std430, binding = 3) buffer Cylinders {
	Cylinder[] cylinders;
};
uniform int cylinders_no;



float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
    return distance(sphere_pos, ray_pos) - sphere_radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return normalize(ray_pos - sphere_pos);
}

float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
    vec3 p = abs(ray_pos - cube_pos) - dims / 2.0;
    float ud = length(max(p, 0.0));
    float n = max(max(min(p.x, 0.0), min(p.y, 0.0)), min(p.z, 0.0));
    return ud + n;
    return distance(cube_pos, ray_pos) - length(dims);
	//return max(max(p.x, p.y), p.z);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 cubeToRay = ray_pos - cube_pos;
	vec3 dist = abs(cubeToRay) - dims / 2.0;
	return
		  dist.x < hitThreshold ? vec3(sign(cubeToRay.x), 0.0, 0.0)
		: dist.y < hitThreshold ? vec3(0.0, sign(cubeToRay.y), 0.0)
		: dist.z < hitThreshold ? vec3(0.0, 0.0, sign(cubeToRay.z))
		: vec3(0.0)
	;
}

float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
    vec3 p = ray_pos - cylinder_pos;
    vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < hitThreshold) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
    vec3 p = ray_pos - cylinder_pos;
    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
    return length(max(d, 0.0)) + max(min(d.x, 0.0), min(d.y, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < hitThreshold) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float signDistTorus(vec3 ray_pos, vec3 torus_pos, float r1, float r2) {   
    vec2 q = vec2(length((ray_pos - torus_pos).xz) - r1, ray_pos.y - torus_pos.y);
    return length(q) - r2;
}

float signDistPrism(vec3 ray_pos, vec3 prism_pos, vec2 h) {
    vec3 q = abs(ray_pos - prism_pos);
    return max(q.z - h.y, max(q.x * 0.866025 + ray_pos.y * 0.5, -ray_pos.y) - h.x * 0.5);
}



float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}



struct RaycastHit {
	bool hit;
	vec3 ray_pos;
	vec3 ray_dir;
	vec3 ray_color;
	vec3 normal;
};
RaycastHit raycast(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * hitThreshold * 100.0;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder
	int obj_index = -1;
	while (distance(init_pos, ray_pos) < farPlane) {
		float minDist = 10000000.0;
		for (int i = 0; i < spheres_no; ++i) {
			float temp = min(minDist, signDistSphere(ray_pos, spheres[i].location, spheres[i].radius));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 0;
				obj_index = i;
			}
		}
		for (int i = 0; i < cubes_no; ++i) {
			float temp = min(minDist, signDistCube(ray_pos, cubes[i].location, cubes[i].dimensions));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 1;
				obj_index = i;
			}
		}
		for (int i = 0; i < cylinders_no; ++i) {
			float temp = min(minDist, signDistCylinder(ray_pos, cylinders[i].location, cylinders[i].radius, cylinders[i].height));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 2;
				obj_index = i;
			}
		}
		ray_pos = ray_pos + ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal =
				  obj_type == 0 ? normalSphere(ray_pos, spheres[obj_index].location, spheres[obj_index].radius)
				: obj_type == 1 ? normalCube(ray_pos, cubes[obj_index].location, cubes[obj_index].dimensions)
				: obj_type == 2 ? normalCylinder(ray_pos, cylinders[obj_index].location, cylinders[obj_index].radius, cylinders[obj_index].height)
				: vec3(0.0)
			;
			return RaycastHit(true, ray_pos, ray_dir, vec3(1.0), normal);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
}

vec3 reflectHit(in RaycastHit hit) {
	return normalize(reflect(normalize(hit.ray_dir), normalize(hit.normal)));
}

vec3 tangent(vec3 v) {
	vec3 arbx = vec3(1.0, 0.0, 0.0);
	vec3 arby = vec3(0.0, 1.0, 0.0);
	vec3 arbz = vec3(0.0, 0.0, 1.0);

	vec3 arbitrary = arbx;
	if (abs(dot(v, arby)) < abs(dot(v, arbitrary))) {
	    arbitrary = arby;
	}
	if (abs(dot(v, arbz)) < abs(dot(v, arbitrary))) {
	    arbitrary = arbz;
	}

	return normalize(cross(v, arbitrary));
}

float angle(vec3 a, vec3 b) {
    return acos(dot(a, b) / (length(a) * length(b)));
}



mat3 rotationMatrix(float angleX, float angleY, float angleZ) {
    float radX = radians(angleX);
    float radY = radians(angleY);
    float radZ = radians(angleZ);

    mat3 rotX = mat3(1.0, 0.0, 0.0,
                     0.0, cos(radX), -sin(radX),
                     0.0, sin(radX), cos(radX));

    mat3 rotY = mat3(cos(radY), 0.0, sin(radY),
                     0.0, 1.0, 0.0,
                     -sin(radY), 0.0, cos(radY));

    mat3 rotZ = mat3(cos(radZ), -sin(radZ), 0.0,
                     sin(radZ), cos(radZ), 0.0,
                     0.0, 0.0, 1.0);

    return rotZ * rotY * rotX;
}
float random(vec2 v) {
    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123 * rng_seed);
}
vec3 rotateVectorRandom(vec3 v, float maxAngle) {
    float randomAngleX = random(v.xy) * maxAngle;
    float randomAngleY = random(v.yz) * maxAngle;
    float randomAngleZ = random(v.zx) * maxAngle;

    mat3 rotMatrix = rotationMatrix(randomAngleX, randomAngleY, randomAngleZ);
    vec3 rotatedVec = rotMatrix * v;

    return rotatedVec;
}



void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));


    int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = 1.0 - (pixel_coords.x * 2.0) / imageSize(img_output).x;
	float ndcY = 1.0 - (pixel_coords.y * 2.0) / imageSize(img_output).y;

	vec4 ndcPoint = vec4(ndcX, ndcY, -1.0, 1.0);

	vec4 worldPoint = inverse(camera_proj * camera_view) * ndcPoint;
	worldPoint /= worldPoint.w;

	vec3 ray_loc = camera_pos;
	vec3 ray_dir = normalize(vec3(worldPoint) - camera_pos);
    vec3 ray_color = vec3(1.0);


	RaycastHit hit = raycast(ray_loc, ray_dir);
	ray_color *= hit.ray_color;
	if (hit.hit == true) {
		int bounces = max_bounces;
		float light_deg = 1.0 / (bounces + 1);
		float light_energy = 1.0 - light_deg;
		while (bounces > 0) {
			vec3 new_dir = reflectHit(hit);
			new_dir = rotateVectorRandom(new_dir, diffusion_angle);
			//new_dir = dot(new_dir, hit.normal) < 0.01 ? -new_dir : new_dir;

			RaycastHit last_hit = raycast(hit.ray_pos, new_dir);
			if (last_hit.hit == false) {
				break;
			}
			hit = last_hit;

			RaycastHit shadow_hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
			vec3 hit_color = hit.ray_color * light_energy;
			if (shadow_hit.hit == true) {
				hit_color *= vec3(0.0);
			}
			ray_color += hit_color;
			light_energy -= light_deg;
			bounces--;
		}
		hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
		if (hit.hit == true) {
			ray_color *= vec3(0.0);
		}
	}
	ray_color = normalize(ray_color);


	vec4 final_color = normalize(clamp(imageLoad(img_output, pixel_coords), 0.0, 1.0) + vec4(ray_color, 1.0));
	final_color.a = 1.0;
    imageStore(img_output, pixel_coords, final_color);
}
