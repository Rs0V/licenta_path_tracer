#version 460 core
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;


uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_pos;


struct Sphere {
	vec3 location;
	float radius;
};
layout (std430, binding = 1) buffer Spheres {
	Sphere[] spheres;
};
uniform int spheres_no;

struct Cube {
	vec3 location;
	vec3 dimensions;
};
layout (std430, binding = 2) buffer Cubes {
	Cube[] cubes;
};
uniform int cubes_no;

struct Cylinder {
	vec3 location;
	float radius;
	float height;
};
layout (std430, binding = 3) buffer Cylinders {
	Cylinder cylinders[];
};
uniform int cylinders_no;



float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
    return distance(sphere_pos, ray_pos) - sphere_radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return normalize(ray_pos - sphere_pos);
}

float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	//dims = vec3(10.0);
    vec3 p = abs(ray_pos - cube_pos) - dims / 2.0;
    float ud = length(max(p, 0.0));
    float n = max(max(min(p.x, 0.0), min(p.y, 0.0)), min(p.z, 0.0));
    return ud + n;
    return distance(cube_pos, ray_pos) - length(dims);
	//return max(max(p.x, p.y), p.z);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 cubeToRay = ray_pos - cube_pos;
	vec3 dist = abs(cubeToRay) - dims / 2.0;
	return
		  dist.x < 0.001 ? vec3(sign(cubeToRay.x), 0.0, 0.0)
		: dist.y < 0.001 ? vec3(0.0, sign(cubeToRay.y), 0.0)
		: dist.z < 0.001 ? vec3(0.0, 0.0, sign(cubeToRay.z))
		: vec3(0.0)
	;
	/*
	vec3 v = normalize(ray_pos - cube_pos);
	vec3 normal = vec3(0.0);
	float maxv = 0.0;
	if (abs(v.x) > maxv) {
		maxv = abs(v.x);
		normal = vec3(sign(v.x), 0.0, 0.0);
	}
	if (abs(v.y) > maxv) {
		maxv = abs(v.y);
		normal = vec3(0.0, sign(v.y), 0.0);
	}
	if (abs(v.z) > maxv) {
		maxv = abs(v.z);
		normal = vec3(0.0, 0.0, sign(v.z));
	}
	return normal;
	*/
}

/*
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, vec2 h) {
    vec2 d = abs(vec2(length(ray_pos.xz), ray_pos.y)) - h;
    return length(max(d, 0.0)) + max(min(d.x, 0.0), min(d.y, 0.0));
}
*/
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
    vec3 p = ray_pos - cylinder_pos;
    vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, ray_pos.z > cylinder_pos.z ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float signDistTorus(vec3 ray_pos, vec3 torus_pos, float r1, float r2) {   
    vec2 q = vec2(length((ray_pos - torus_pos).xz) - r1, ray_pos.y - torus_pos.y);
    return length(q) - r2;
}

float signDistPrism(vec3 ray_pos, vec3 prism_pos, vec2 h) {
    vec3 q = abs(ray_pos - prism_pos);
    return max(q.z - h.y, max(q.x * 0.866025 + ray_pos.y * 0.5, -ray_pos.y) - h.x * 0.5);
}



float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}



vec3 light_pos;

struct RaycastHit {
	bool hit;
	vec3 ray_pos;
	vec3 ray_color;
	vec3 normal;
};
RaycastHit raycast(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * 0.01;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder
	int obj_index = -1;
	while (distance(init_pos, ray_pos) < 1000.0) {
		float minDist = 10000000.0;
		for (int i = 0; i < spheres_no; ++i) {
			float temp = min(minDist, signDistSphere(ray_pos, spheres[i].location, spheres[i].radius));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 0;
				obj_index = i;
			}
		}
		for (int i = 0; i < cubes_no; ++i) {
			float temp = min(minDist, signDistCube(ray_pos, cubes[i].location, cubes[i].dimensions));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 1;
				obj_index = i;
			}
		}
		for (int i = 0; i < cylinders_no; ++i) {
			float temp = min(minDist, signDistCylinder(ray_pos, cylinders[i].location, cylinders[i].radius, cylinders[i].height));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 2;
				obj_index = i;
			}
		}
		ray_pos = ray_pos + ray_dir * minDist;
		
		if (minDist < 0.0001) {
			vec3 normal =
				  obj_type == 0 ? normalSphere(ray_pos, spheres[obj_index].location, spheres[obj_index].radius)
				: obj_type == 1 ? normalCube(ray_pos, cubes[obj_index].location, cubes[obj_index].dimensions)
				: obj_type == 2 ? normalCylinder(ray_pos, cylinders[obj_index].location, cylinders[obj_index].radius, cylinders[obj_index].height)
				: vec3(0.0)
			;
			return RaycastHit(true, ray_pos, vec3(1.0), normal);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0));
}



mat3 rotationMatrix(float angleX, float angleY, float angleZ) {
    float radX = radians(angleX);
    float radY = radians(angleY);
    float radZ = radians(angleZ);

    mat3 rotX = mat3(1.0, 0.0, 0.0,
                     0.0, cos(radX), -sin(radX),
                     0.0, sin(radX), cos(radX));

    mat3 rotY = mat3(cos(radY), 0.0, sin(radY),
                     0.0, 1.0, 0.0,
                     -sin(radY), 0.0, cos(radY));

    mat3 rotZ = mat3(cos(radZ), -sin(radZ), 0.0,
                     sin(radZ), cos(radZ), 0.0,
                     0.0, 0.0, 1.0);

    return rotZ * rotY * rotX;
}
vec3 rotateVectorRandom(vec3 v, float maxAngle) {
    float randomAngleX = fract(sin(dot(v.xy, vec2(12.9898, 78.233))) * 43758.5453) * maxAngle;
    float randomAngleY = fract(sin(dot(v.yz, vec2(12.9898, 78.233))) * 43758.5453) * maxAngle;
    float randomAngleZ = fract(sin(dot(v.zx, vec2(12.9898, 78.233))) * 43758.5453) * maxAngle;

    mat3 rotMatrix = rotationMatrix(randomAngleX, randomAngleY, randomAngleZ);
    vec3 rotatedVec = rotMatrix * v;

    return rotatedVec;
}



void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));


    int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = 1.0f - (pixel_coords.x * 2.0f) / imageSize(img_output).x;
	float ndcY = 1.0f - (pixel_coords.y * 2.0f) / imageSize(img_output).y;

	vec4 ndcPoint = vec4(ndcX, ndcY, -1.0f, 1.0f);

	vec4 worldPoint = inverse(camera_proj * camera_view) * ndcPoint;
	worldPoint /= worldPoint.w;

	vec3 ray_loc = camera_pos;
	vec3 ray_dir = normalize(vec3(worldPoint) - camera_pos);
    vec3 ray_color = vec3(1.0);


	light_pos = vec3(-20.0, -10.0, 10.0);

	RaycastHit hit = raycast(ray_loc, ray_dir);
	ray_color *= hit.ray_color;
	if (hit.hit == true) {
		int bounces = 2;
		float light_deg = 1.0 / (bounces + 1);
		float light_energy = 1.0 - light_deg;
		while (bounces > 0) {
			vec3 new_dir = normalize(reflect(normalize(hit.ray_pos + ray_dir), normalize(hit.normal)));
			RaycastHit last_hit = raycast(hit.ray_pos, rotateVectorRandom(new_dir, 10.0));
			if (last_hit.hit == false) {
				break;
			}
			hit = last_hit;

			RaycastHit shadow_hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
			vec3 hit_color = hit.ray_color * light_energy;
			if (shadow_hit.hit == true) {
				hit_color *= vec3(0.0);
			}
			ray_color += hit_color;
			light_energy -= light_deg;
			bounces--;
		}
		hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
		if (hit.hit == true) {
			ray_color *= vec3(0.0);
		}
	}
	ray_color = normalize(ray_color);


    imageStore(img_output, pixel_coords, vec4(ray_color, 1.0));
}
