#version 450 core
#extension GL_ARB_shading_language_include : require
#include "/basic_shapes.comp" //! #include "./basic_shapes.comp"
#include "/materials.comp" //! #include "./materials.comp"
#include "/lights.comp" //! #include "./lights.comp"
#include "/shader_debug.comp" //! #include "./shader_debug.comp"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;
uniform uvec2 tile_offset;



//  0 - accumulate samples;
//  1 - rendered frame only
// -1 - reset image buffer
uniform int scene_change = 0;

uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_loc;

uniform float random_f01;
uniform int samples;

const float hitThreshold = 0.001;
const float farPlane = 1000.0;

uniform sampler2D blueNoise;



#define spheres_no 100
#define cubes_no 100
#define cylinders_no 100
#define cones_no 100
#define booleans_no 100
#define point_lights_no 100
#define principled_bsdfs_no 100
#define volume_scatters_no 100
layout (std430, binding = 1) buffer BasicShapes {
	Sphere spheres[spheres_no];
	Cube cubes[cubes_no];
	Cylinder cylinders[cylinders_no];
	Cone cones[cones_no];
	Boolean booleans[booleans_no];
};
layout (std430, binding = 2) buffer Props {
	PointLight point_lights[point_lights_no];
	PrincipledBSDF principled_bsdfs[principled_bsdfs_no];
	VolumeScatter volume_scatters[volume_scatters_no];
};



struct RaycastHit {
	bool hit;
	vec3 location;
	vec3 direction;
	vec3 normal;

	int obj_type;
	int obj_index;

	int material_type;
	int material_index;
};

float signDistBlendedObj(float obj_dist_1, float obj_dist_2, int booleanType = -1, float blend = 0.5) {
	switch(booleanType) {
	case -1:
		return min(obj_dist_1, obj_dist_2);
	case 0:
		return smoothUnion(obj_dist_1, obj_dist_2, blend);
	case 1:
		return smoothIntersect(obj_dist_1, obj_dist_2, blend);
	case 2:
		return smoothDifference(obj_dist_1, obj_dist_2, blend);
	}
}
float signDistObj(vec3 ray_loc, int obj_type, int obj_index) {
	switch(obj_type) {
	case 0:
		return signDistSphere(ray_loc, spheres[obj_index]);
	case 1:
		return signDistCube(ray_loc, cubes[obj_index]);
	case 2:
		return signDistCylinder(ray_loc, cylinders[obj_index]);
	case 3:
		return signDistCone(ray_loc, cones[obj_index]);
	}
	return -999999999;
}
float signDistScene(vec3 ray_loc) {
	float minDist = 999999999;

	// Check for closest Sphere
	for (int i = 0; i < spheres_no; i++) {
		if (spheres[i].visible == 0) {
			continue;
		}

		float closest = signDistSphere(ray_loc, spheres[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 0 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}

	// Check for closest Cube
	for (int i = 0; i < cubes_no; i++) {
		if (cubes[i].visible == 0) {
			continue;
		}

		float closest = signDistCube(ray_loc, cubes[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 1 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}
	
	// Check for closest Cylinder
	for (int i = 0; i < cylinders_no; i++) {
		if (cylinders[i].visible == 0) {
			continue;
		}

		float closest = signDistCylinder(ray_loc, cylinders[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 2 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}
	
	// Check for closest Cone
	for (int i = 0; i < cones_no; i++) {
		if (cones[i].visible == 0) {
			continue;
		}

		float closest = signDistCone(ray_loc, cones[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 3 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}

	return minDist;
}

vec3 normalScene(vec3 ray_loc) {
	const float epsilon = 0.001;
	const mat3x3 d = mat3x3(
		vec3(epsilon, 0, 0),
		vec3(0, epsilon, 0),
		vec3(0, 0, epsilon)
	);

	float cd = signDistScene(ray_loc);
	return normalize((vec3(signDistScene(ray_loc + d[0]), signDistScene(ray_loc + d[1]), signDistScene(ray_loc + d[2])) - cd) / epsilon);
}


RaycastHit raycast(vec3 ray_loc, vec3 ray_dir) {
	vec3 init_loc = ray_loc;
	ray_loc += ray_dir * hitThreshold * 100.0;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder, 3 - cone
	int obj_index = -1;
	float minimumDistance = 999999999;
	float mDepsDistMin = 0.5;
	float mDepsDistDiff = 0.1;
	int mDeqCount = 0;
	while (distance(init_loc, ray_loc) < farPlane) {
		float minDist = 999999999;

		// Check for closest Sphere
		for (int i = 0; i < spheres_no; i++) {
			if (spheres[i].visible == 0) {
				continue;
			}

			float closest = signDistSphere(ray_loc, spheres[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 0 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type  = 0;
				obj_index = i;
			}
		}

		// Check for closest Cube
		for (int i = 0; i < cubes_no; i++) {
			if (cubes[i].visible == 0) {
				continue;
			}

			float closest = signDistCube(ray_loc, cubes[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 1 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 1;
				obj_index = i;
			}
		}
		
		// Check for closest Cylinder
		for (int i = 0; i < cylinders_no; i++) {
			if (cylinders[i].visible == 0) {
				continue;
			}

			float closest = signDistCylinder(ray_loc, cylinders[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 2 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 2;
				obj_index = i;
			}
		}
		
		// Check for closest Cone
		for (int i = 0; i < cones_no; i++) {
			if (cones[i].visible == 0) {
				continue;
			}

			float closest = signDistCone(ray_loc, cones[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 3 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 3;
				obj_index = i;
			}
		}
		
		
		// Minimum distance aproximation for better performance
		// when tracing against parallel surfaces
		if (distance(minimumDistance, minDist) < mDepsDistDiff && minDist < mDepsDistMin) {
			minDist *= pow(2, mDeqCount + 1);
			mDeqCount++;
		} else {
			minimumDistance = minDist;
			mDeqCount = 0;
		}
		ray_loc += ray_dir * minDist;


		if (minDist < hitThreshold) {
			int mat_type =
				  obj_type == 0 ? spheres[obj_index].material_type
				: obj_type == 1 ? cubes[obj_index].material_type
				: obj_type == 2 ? cylinders[obj_index].material_type
				: obj_type == 3 ? cones[obj_index].material_type
				: -1
			;
			int mat_index =
				  obj_type == 0 ? spheres[obj_index].material_index
				: obj_type == 1 ? cubes[obj_index].material_index
				: obj_type == 2 ? cylinders[obj_index].material_index
				: obj_type == 3 ? cones[obj_index].material_index
				: -1
			;

			return RaycastHit(true, ray_loc, ray_dir, normalScene(ray_loc), obj_type, obj_index, mat_type, mat_index);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), -1, -1, -1, -1);
}
RaycastHit raycast_light(vec3 ray_loc, vec3 ray_dir, inout PointLight point_light) {
	vec3 init_loc = ray_loc;
	ray_loc += ray_dir * hitThreshold * 100.0;

	while (distance(init_loc, ray_loc) < farPlane) {
		float minDist = 999999999;
		float temp = min(minDist, signDistSphere(ray_loc, point_light.location, point_light.radius));
		if (temp < minDist) {
			minDist = temp;
		}
		ray_loc += ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal = normalSphere(ray_loc, point_light.location, point_light.radius);
			return RaycastHit(true, ray_loc, ray_dir, normal, -1, -1, -1, -1);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), -1, -1, -1, -1);
}

RaycastHit reflectRay(inout RaycastHit ray) {
	return RaycastHit(
		ray.hit,
		ray.location,
		normalize(reflect(normalize(ray.direction), normalize(ray.normal))),
		ray.normal,
		ray.obj_type,
		ray.obj_index,
		ray.material_type,
		ray.material_index
	);
}



float random(vec2 uv) {
	return texture(blueNoise, uv + vec2(random_f01, fract(random_f01 * 7.931199))).x;
}
vec3 randomVectorInSphericalCap(vec2 uv, vec3 normal, float max_angle, bool signedSpread = true) {
	vec3 tg1  = tangent(normal);
	vec3 tg2  = normalize(cross(normal, tg1));

	float min_angle = signedSpread ? -max_angle / 2.0 : 0.0;
	max_angle       = signedSpread ?  max_angle / 2.0 : max_angle;

	float theta1 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.000, 0.543)));
	float theta2 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.341, 0.121)));
	float theta3 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.859, 0.652)));

	vec3 rot1 = rotateVector(normal, tg1,    theta1);
	vec3 rot2 = rotateVector(rot1,   tg2,    theta2);
	vec3 rot3 = rotateVector(rot2,   normal, theta3);
	
	return rot3;
}
vec3 randomVectorInHemisphere(vec2 uv, vec3 normal) {
	return randomVectorInSphericalCap(uv, normal, 180.0);
}


vec3 fresnel_schlick(float cos_theta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cos_theta, 5.0);
}
float ndf_ggx(vec3 normal, vec3 half_vector, float roughness) {
    float r2 = roughness * roughness;
    float NdotH = max(dot(normal, half_vector), 0.0);
    float NdotH2 = NdotH * NdotH;

    float denominator = (NdotH2 * (r2 - 1.0) + 1.0);
    return r2 / (pi * denominator * denominator);
}
float geometry_schlick_ggx(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}
float geometry_smith(vec3 normal, vec3 view_dir, vec3 light_dir, float roughness) {
    float NdotV = max(dot(normal, view_dir), 0.0);
    float NdotL = max(dot(normal, light_dir), 0.0);
    float ggx1 = geometry_schlick_ggx(NdotV, roughness);
    float ggx2 = geometry_schlick_ggx(NdotL, roughness);
    return ggx1 * ggx2;
}

vec3 generate_diffuse_ray(vec2 uv, inout RaycastHit hit) {
	float rdisp = fract((hit.location.x + hit.location.y + hit.location.z) * 23.49789);
    return randomVectorInHemisphere(uv + vec2(rdisp, fract(rdisp * 3.65243)), hit.normal);
}
vec3 generate_glossy_ray(vec2 uv, inout RaycastHit hit, float roughness) {
	float rdisp = fract((hit.location.x + hit.location.y + hit.location.z) * 19.62173);
	return normalize(mix(reflectRay(hit).direction, randomVectorInHemisphere(uv + vec2(rdisp, fract(rdisp * 1.722459)), hit.normal), roughness));
}

vec3 lambertian_shading(inout RaycastHit hit, inout PointLight point_light) {
    vec3 light_dir = normalize(point_light.location - hit.location);

	float light_dist = distance(point_light.location, hit.location);
	float light_attenuation = 1.0 / (0.8 + 0.1 * light_dist + 0.03 * light_dist * light_dist);
	float light_intensity = point_light.intensity * light_attenuation;

    float diffuse_intensity = max(dot(hit.normal, light_dir), 0.0) * light_intensity;
    vec3 diffuse_color = principled_bsdfs[hit.material_index].albedo * point_light.color * diffuse_intensity;
    return diffuse_color;
}
vec3 cook_torrance_brdf(inout RaycastHit hit, inout PointLight point_light) {
    vec3 light_dir = normalize(point_light.location - hit.location);
	vec3 view_dir = normalize(camera_loc - hit.location);
    vec3 half_vector = normalize(view_dir + light_dir);

    vec3 F0 = mix(vec3(0.04), vec3(principled_bsdfs[hit.material_index].reflectance), principled_bsdfs[hit.material_index].metallic);

    float NDF = ndf_ggx(hit.normal, half_vector, principled_bsdfs[hit.material_index].roughness);
    float G = geometry_smith(hit.normal, view_dir, light_dir, principled_bsdfs[hit.material_index].roughness);
    vec3 F = fresnel_schlick(dot(hit.normal, half_vector), F0);

    float denominator = 4.0 * max(dot(hit.normal, view_dir), 0.0) * max(dot(hit.normal, light_dir), 0.0);
    vec3 specular = (NDF * G * F) / max(denominator, 0.001);

    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - principled_bsdfs[hit.material_index].metallic;

	float light_dist = distance(point_light.location, hit.location);
	float light_attenuation = 1.0 / (0.8 + 0.1 * light_dist + 0.03 * light_dist * light_dist);
	float light_intensity = point_light.intensity * light_attenuation;

    float NdotL = max(dot(hit.normal, light_dir), 0.0);
    return (kD * principled_bsdfs[hit.material_index].albedo + specular * light_intensity) * NdotL;
}

vec3 pbr_shading(inout RaycastHit hit, inout PointLight point_light) {
    vec3 vdiffuse = lambertian_shading(hit, point_light);
    vec3 vspecular = cook_torrance_brdf(hit, point_light);

	return vdiffuse * vspecular;
}



void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(tile_offset);
	vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));

	if (scene_change == 1) {
		imageStore(img_output, pixel_coords, vec4(vec3(0.0), 1.0));
		return;
	}



	int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = uv.x * 2.0 - 1.0;
	float ndcY = 1.0 - uv.y * 2.0;

	vec4 clipSpace = vec4(ndcX, ndcY, 0.0, 1.0);
	vec4 viewSpace = inverse(camera_proj) * clipSpace;
	viewSpace.xyz /= viewSpace.w;
	vec4 worldSpace = inverse(camera_view) * viewSpace;
	//vec4 worldSpace = inverse(camera_view * camera_proj) * vec4(ndcX, ndcY, -1.0, 1.0);
	worldSpace.xyz /= worldSpace.w;

	//print_mat4(camera_proj);
	//print_mat4(camera_view);

	vec3 ray_loc = camera_loc;
	vec3 ray_dir = normalize(worldSpace.xyz - camera_loc);
	vec3 ray_color = vec3(0.0);

	//imageStore(img_output, pixel_coords, vec4(abs(ray_dir.x) * (ray_dir.x > 0.0 ? red : neg(red)), 1.0));



	const int max_diffuse_bounces = 3;
	const int max_glossy_bounces  = 3;

	RaycastHit hit = raycast(ray_loc, ray_dir);
	if (hit.hit == true) {
		float dist = 0.0;
		RaycastHit copy_hit = hit;
		RaycastHit last_hit;

		// Diffuse rays
		vec3 diffuse_color = vec3(0.0);
		int bounces = max_diffuse_bounces;
		while (bounces > 0) {
			last_hit = hit;


			// Need to make a special raycast_light function that tests hits taking into account light's radius
			//RaycastHit shadow_hit = raycast_light(ray_loc, ray_dir);

			//vec3 light_contrib = light_color * mix(0.0, light_power, 1.0 - min(1.0, distance(light_loc, hit.ray_loc) / light_radius));
			for (int i = 0; i < point_lights_no; i++) {
				diffuse_color += pbr_shading(hit, point_lights[i]);
			}

			hit = raycast(hit.location, generate_diffuse_ray(uv, hit));


			dist += distance(hit.location, last_hit.location);
			bounces--;
		}
		diffuse_color /= float(max_diffuse_bounces);


		// Go back to initial hit
		dist = 0.0;
		hit = copy_hit;

		// Glossy rays
		vec3 glossy_color = vec3(0.0);
		bounces = max_glossy_bounces;
		while (bounces > 0) {
			last_hit = hit;


			//vec3 light_contrib = light_color * mix(0.0, light_power, 1.0 - min(1.0, distance(light_loc, hit.ray_loc) / light_radius));
			for (int i = 0; i < point_lights_no; i++) {
				glossy_color += pbr_shading(hit, point_lights[i]);
			}

			hit = raycast(hit.location, generate_glossy_ray(uv, hit, principled_bsdfs[hit.material_index].roughness));


			dist += distance(hit.location, last_hit.location);
			bounces--;
		}
		glossy_color /= float(max_glossy_bounces);


		ray_color = (diffuse_color + glossy_color) / 2.0;
	}
	ray_color = max(ray_color, 0.0);



	vec3 currect_pixel = max(imageLoad(img_output, pixel_coords).xyz, 0.0);
	vec4 final_color = vec4((currect_pixel + ray_color), 1.0);
	imageStore(img_output, pixel_coords, final_color);


	//imageStore(img_output, pixel_coords, texture(blueNoise, uv));
}
