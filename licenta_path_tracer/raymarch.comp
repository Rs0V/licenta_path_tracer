#version 460 core
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;


uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_pos;
uniform int rng_seed;
uniform int reset = 0; // -1: reseting, 0: reseted, 1: have to reset
uniform int samples;

const float hitThreshold = 0.001;
const float farPlane = 1000.0;
const int max_bounces = 8;
const float diffusion_angle = 80.0; // in degrees
uniform vec3 light_pos = vec3(-20.0, -20.0, 20.0);



vec3 rgb2hsv(vec3 color) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(color.bg, K.wz), vec4(color.gb, K.xy), step(color.b, color.g));
    vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv2rgb(vec3 color) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);
    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);
}

vec3 hueShift(vec3 color, float hue) {
    vec3 hsv = rgb2hsv(color);
    hsv.x = mod(hsv.x + hue / 360.0, 1.0);
    return hsv2rgb(hsv);
}
vec3 saturationMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.y *= factor;
    return hsv2rgb(hsv);
}
vec3 valueMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.z *= factor;
    return hsv2rgb(hsv);
}



struct Sphere {
	vec3 location;
	float radius;
	vec4 color;
};
layout (std430, binding = 1) buffer Spheres {
	Sphere[] spheres;
};
uniform int spheres_no;

struct Cube {
	vec3 location;
	vec3 dimensions;
	vec4 color;
};
layout (std430, binding = 2) buffer Cubes {
	Cube[] cubes;
};
uniform int cubes_no;

struct Cylinder {
	vec3 location;
	float radius;
	float height;
	vec4 color;
};
layout (std430, binding = 3) buffer Cylinders {
	Cylinder[] cylinders;
};
uniform int cylinders_no;



float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return distance(sphere_pos, ray_pos) - sphere_radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return normalize(ray_pos - sphere_pos);
}

float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 p = abs(ray_pos - cube_pos) - dims / 2.0;
	float ud = length(max(p, 0.0));
	float n = max(max(min(p.x, 0.0), min(p.y, 0.0)), min(p.z, 0.0));
	return ud + n;
	return distance(cube_pos, ray_pos) - length(dims);
	//return max(max(p.x, p.y), p.z);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 cubeToRay = ray_pos - cube_pos;
	vec3 dist = abs(cubeToRay) - dims / 2.0;
	return
		  dist.x < hitThreshold ? vec3(sign(cubeToRay.x), 0.0, 0.0)
		: dist.y < hitThreshold ? vec3(0.0, sign(cubeToRay.y), 0.0)
		: dist.z < hitThreshold ? vec3(0.0, 0.0, sign(cubeToRay.z))
		: vec3(0.0)
	;
}

float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < hitThreshold) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return length(max(d, 0.0)) + max(min(d.x, 0.0), min(d.y, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < hitThreshold) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float signDistTorus(vec3 ray_pos, vec3 torus_pos, float r1, float r2) {   
	vec2 q = vec2(length((ray_pos - torus_pos).xz) - r1, ray_pos.y - torus_pos.y);
	return length(q) - r2;
}

float signDistPrism(vec3 ray_pos, vec3 prism_pos, vec2 h) {
	vec3 q = abs(ray_pos - prism_pos);
	return max(q.z - h.y, max(q.x * 0.866025 + ray_pos.y * 0.5, -ray_pos.y) - h.x * 0.5);
}



float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}



struct RaycastHit {
	bool hit;
	vec3 ray_pos;
	vec3 ray_dir;
	vec4 ray_color;
	vec3 normal;
	int obj_type;
	int obj_index;
};
RaycastHit raycast(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * hitThreshold * 100.0;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder
	int obj_index = -1;
	while (distance(init_pos, ray_pos) < farPlane) {
		float minDist = 10000000.0;
		for (int i = 0; i < spheres_no; ++i) {
			float temp = min(minDist, signDistSphere(ray_pos, spheres[i].location, spheres[i].radius));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 0;
				obj_index = i;
			}
		}
		for (int i = 0; i < cubes_no; ++i) {
			float temp = min(minDist, signDistCube(ray_pos, cubes[i].location, cubes[i].dimensions));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 1;
				obj_index = i;
			}
		}
		for (int i = 0; i < cylinders_no; ++i) {
			float temp = min(minDist, signDistCylinder(ray_pos, cylinders[i].location, cylinders[i].radius, cylinders[i].height));
			if (temp < minDist) {
				minDist = temp;
				obj_type = 2;
				obj_index = i;
			}
		}
		ray_pos = ray_pos + ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal =
				  obj_type == 0 ? normalSphere(ray_pos, spheres[obj_index].location, spheres[obj_index].radius)
				: obj_type == 1 ? normalCube(ray_pos, cubes[obj_index].location, cubes[obj_index].dimensions)
				: obj_type == 2 ? normalCylinder(ray_pos, cylinders[obj_index].location, cylinders[obj_index].radius, cylinders[obj_index].height)
				: vec3(0.0)
			;
			vec4 color =
				  obj_type == 0 ? spheres[obj_index].color
				: obj_type == 1 ? cubes[obj_index].color
				: obj_type == 2 ? cylinders[obj_index].color
				: vec4(1.0)
			;
			return RaycastHit(true, ray_pos, ray_dir, color, normal, obj_type, obj_index);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec4(0.0), vec3(0.0), -1, -1);
}
RaycastHit raycast_light(vec3 ray_pos, vec3 ray_dir) {
	vec3 init_pos = ray_pos;
	ray_pos += ray_dir * hitThreshold * 100.0;

	while (distance(init_pos, ray_pos) < farPlane) {
		float minDist = 10000000.0;
		float temp = min(minDist, signDistSphere(ray_pos, light_pos, 2));
		if (temp < minDist) {
			minDist = temp;
		}
		ray_pos = ray_pos + ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal = normalSphere(ray_pos, light_pos, 2);
			return RaycastHit(true, ray_pos, ray_dir, vec4(1.0), normal, -1, -1);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec4(0.0), vec3(0.0), -1, -1);
}

vec3 reflectHit(in RaycastHit hit) {
	return normalize(reflect(normalize(hit.ray_dir), normalize(hit.normal)));
}

vec3 tangent(vec3 v) {
	vec3 arbx = vec3(1.0, 0.0, 0.0);
	vec3 arby = vec3(0.0, 1.0, 0.0);
	vec3 arbz = vec3(0.0, 0.0, 1.0);

	vec3 arbitrary = arbx;
	if (abs(dot(v, arby)) < abs(dot(v, arbitrary))) {
		arbitrary = arby;
	}
	if (abs(dot(v, arbz)) < abs(dot(v, arbitrary))) {
		arbitrary = arbz;
	}

	return normalize(cross(v, arbitrary));
}

float angle(vec3 a, vec3 b) {
	return acos(dot(a, b) / (length(a) * length(b)));
}



mat3 rotationMatrix(float angleX, float angleY, float angleZ) {
	float radX = radians(angleX);
	float radY = radians(angleY);
	float radZ = radians(angleZ);

	mat3 rotX = mat3(1.0, 0.0, 0.0,
					 0.0, cos(radX), -sin(radX),
					 0.0, sin(radX), cos(radX));

	mat3 rotY = mat3(cos(radY), 0.0, sin(radY),
					 0.0, 1.0, 0.0,
					 -sin(radY), 0.0, cos(radY));

	mat3 rotZ = mat3(cos(radZ), -sin(radZ), 0.0,
					 sin(radZ), cos(radZ), 0.0,
					 0.0, 0.0, 1.0);

	return rotZ * rotY * rotX;
}
float random(vec2 v) {
	return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123 * rng_seed);
}
vec3 rotateVectorRandom(vec3 v, float maxAngle) {
	float randomAngleX = random(v.xy) * maxAngle;
	float randomAngleY = random(v.yz) * maxAngle;
	float randomAngleZ = random(v.zx) * maxAngle;

	mat3 rotMatrix = rotationMatrix(randomAngleX, randomAngleY, randomAngleZ);
	vec3 rotatedVec = rotMatrix * v;

	return rotatedVec;
}


uint packColor(vec4 color) {
	return uint(color.r * 255.0) << 24 |
		   uint(color.g * 255.0) << 16 |
		   uint(color.b * 255.0) <<  8 |
		   uint(color.a * 255.0);
}
vec4 unpackColor(uint packedColor) {
	return vec4(
		float((packedColor >> 24) & 0xFF) / 255.0,
		float((packedColor >> 16) & 0xFF) / 255.0,
		float((packedColor >>  8) & 0xFF) / 255.0,
		float( packedColor        & 0xFF) / 255.0
	);
}


float mulAdd(float a, float b) {
	return fma(a, b, a);
}


void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));

	if (reset == -1) {
		imageStore(img_output, pixel_coords, vec4(0.0, 0.0, 0.0, 1.0));
		return;
	}


	int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = 1.0 - (pixel_coords.x * 2.0) / imageSize(img_output).x;
	float ndcY = 1.0 - (pixel_coords.y * 2.0) / imageSize(img_output).y;

	vec4 ndcPoint = vec4(ndcX, ndcY, -1.0, 1.0);

	vec4 worldPoint = inverse(camera_proj * camera_view) * ndcPoint;
	worldPoint /= worldPoint.w;

	vec3 ray_loc = camera_pos;
	vec3 ray_dir = normalize(vec3(worldPoint) - camera_pos);
	vec3 ray_color = vec3(1.0);


	RaycastHit hit = raycast(ray_loc, ray_dir);
	if (hit.hit == true) {
		//ray_color = vec3(hit.ray_color);
		RaycastHit shadow_hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
		if (shadow_hit.hit == true) {
			if (hit.obj_type == shadow_hit.obj_type
			&& hit.obj_index == shadow_hit.obj_index) {
				ray_color *= 0.5;
				//ray_color *= vec3(0.7, 0.0, 0.0);
			} else if (distance(hit.ray_pos, shadow_hit.ray_pos) < distance(hit.ray_pos, light_pos)) {
				ray_color *= 0.5;
				//ray_color = vec3(shadow_hit.ray_color) * 0.5;
				//ray_color *= hueShift(vec3(0.0, 0.7, 0.0), mulAdd(hit.obj_type + 1, (hit.obj_index + 1) * 10) * 30);
			}
		}
	} else {
		ray_color = vec3(0.0);
	}
	hit = raycast_light(ray_loc, ray_dir);
	if (hit.hit == true) {
		ray_color = vec3(1.0, 0.0, 1.0);
	}
	/*
	ray_color *= hit.ray_color;
	if (hit.hit == true) {
		int bounces = max_bounces;
		float dist = 0.0;
		float light_intensity = 1.0;

		while (bounces > 0) {
			vec3 new_dir = reflectHit(hit);
			new_dir = rotateVectorRandom(new_dir, diffusion_angle);

			RaycastHit last_hit = raycast(hit.ray_pos, new_dir);
			if (last_hit.hit == false) {
				break;
			}

			RaycastHit shadow_hit = raycast(last_hit.ray_pos, normalize(light_pos - last_hit.ray_pos));
			vec3 hit_color = last_hit.ray_color;
			if (shadow_hit.hit == true) {
				hit_color *= vec3(0.0);
			}
			dist += distance(last_hit.ray_pos, hit.ray_pos);
			float light_energy = light_intensity / (distance(light_pos, last_hit.ray_pos) + dist);
			ray_color += hit_color * light_energy; //mix(vec3(0.22, 0.014, 0.002), vec3(0.3, 0.6, 0.8), light_energy);
			
			hit = last_hit;
			bounces--;
		}
		hit = raycast(hit.ray_pos, normalize(light_pos - hit.ray_pos));
		if (hit.hit == true) {
			ray_color *= vec3(0.0);
		}
	}
	ray_color = max((ray_color), 0.0);
	*/


	vec3 currect_pixel = max(vec3(imageLoad(img_output, pixel_coords)), 0.0);
	vec4 final_color = vec4((currect_pixel + ray_color), 1.0);
	final_color.a = 1.0;
	if (reset == 1) {
		imageStore(img_output, pixel_coords, vec4(ray_color * samples, 1.0));
	}
	else if (reset == 0) {
		imageStore(img_output, pixel_coords, final_color);
	}
}
