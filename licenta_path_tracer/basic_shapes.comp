
#include "/utils.comp" //! #include "./utils.comp"

float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}
float smoothUnion(float a, float b, float k) {
	float h = clamp(0.5 + (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) - k * h * (1.0 - h);
}
float smoothIntersect(float a, float b, float k) {
	float h = clamp(0.5 - (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) + k * h * (1.0 - h);
}
float smoothDifference(float a, float b, float k) {
	swap(a, b);
	float h = clamp(0.5 - (b + a) / 2 / k, 0.0, 1.0);
	return mix(b, -a, h) + k * h * (1.0 - h);
}



struct Sphere {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float pad3[3];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return distance(sphere_pos, ray_pos) - sphere_radius;
}

struct Cube {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	vec3 dimensions;
	float pad3;

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 q = abs(ray_pos - cube_pos) - dims / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

struct Cylinder {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float height;
	float pad3[2];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec2 d = abs(vec2(length(ray_pos.xy - cylinder_pos.xy), ray_pos.z - cylinder_pos.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

struct Cone {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float height;
	float pad3[2];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base in 2D
	float angle = atan(cone_radius / 2.0 / cone_height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone_height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_pos.xy - cone_pos.xy), ray_pos.z - cone_pos.z);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
