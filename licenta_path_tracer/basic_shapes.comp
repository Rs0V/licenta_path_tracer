
#include "/utils.comp" //! #include "./utils.comp"

float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}
float smoothUnion(float a, float b, float k) {
	float h = clamp(0.5 + (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) - k * h * (1.0 - h);
}
float smoothIntersect(float a, float b, float k) {
	float h = clamp(0.5 - (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) + k * h * (1.0 - h);
}
float smoothDifference(float a, float b, float k) {
	swap(a, b);
	float h = clamp(0.5 - (b + a) / 2 / k, 0.0, 1.0);
	return mix(b, -a, h) + k * h * (1.0 - h);
}



struct Sphere {
	vec3 location;
	int visible;

	vec3 rotation;
	int affectWorld;

	vec3 scale;
	float radius;

	int type;
	int index;
	int material_type;
	int material_index;
};
float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return distance(sphere_pos, ray_pos) - sphere_radius;
}
float signDistSphere(vec3 ray_pos, inout Sphere sphere) {
	vec3 trp = ray_pos; // transformed ray_pos
	trp    -= sphere.location;
	trp.yz *= rot2D(radians(sphere.rotation.x));
	trp.xz *= rot2D(radians(sphere.rotation.y));
	trp.xy *= rot2D(radians(sphere.rotation.z));
	trp    /= sphere.scale;

	return length(trp) - sphere.radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistSphere(ray_pos     , sphere_pos, sphere_radius);
    float nx = signDistSphere(ray_pos + dx, sphere_pos, sphere_radius) - d;
    float ny = signDistSphere(ray_pos + dy, sphere_pos, sphere_radius) - d;
    float nz = signDistSphere(ray_pos + dz, sphere_pos, sphere_radius) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalSphere(vec3 ray_pos, inout Sphere sphere) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistSphere(ray_pos     , sphere.location, sphere.radius);
    float nx = signDistSphere(ray_pos + dx, sphere.location, sphere.radius) - d;
    float ny = signDistSphere(ray_pos + dy, sphere.location, sphere.radius) - d;
    float nz = signDistSphere(ray_pos + dz, sphere.location, sphere.radius) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cube {
	vec3 location;
	int visible;

	vec3 rotation;
	int affectWorld;

	vec3 scale;
	int material_type;

	vec3 dimensions;
	int material_index;

	int type;
	int index;
};
float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 q = abs(ray_pos - cube_pos) - dims / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
float signDistCube(vec3 ray_pos, inout Cube cube) {
	vec3 trp = ray_pos; // transformed ray_pos
	trp    -= cube.location;
	trp.yz *= rot2D(radians(cube.rotation.x));
	trp.xz *= rot2D(radians(cube.rotation.y));
	trp.xy *= rot2D(radians(cube.rotation.z));
	trp    /= cube.scale;

	vec3 q = abs(trp) - cube.dimensions / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCube(ray_pos     , cube_pos, dims);
    float nx = signDistCube(ray_pos + dx, cube_pos, dims) - d;
    float ny = signDistCube(ray_pos + dy, cube_pos, dims) - d;
    float nz = signDistCube(ray_pos + dz, cube_pos, dims) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCube(vec3 ray_pos, inout Cube cube) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCube(ray_pos     , cube.location, cube.dimensions);
    float nx = signDistCube(ray_pos + dx, cube.location, cube.dimensions) - d;
    float ny = signDistCube(ray_pos + dy, cube.location, cube.dimensions) - d;
    float nz = signDistCube(ray_pos + dz, cube.location, cube.dimensions) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cylinder {
	vec3 location;
	float radius;

	vec3 rotation;
	float height;

	vec3 scale;
	int visible;

	int affectWorld;
	int type;
	int index;
	int material_type;

	int material_index;
};
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec2 d = abs(vec2(length(ray_pos.xy - cylinder_pos.xy), ray_pos.z - cylinder_pos.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
float signDistCylinder(vec3 ray_pos, inout Cylinder cylinder) {
	vec3 trp = ray_pos; // transformed ray_pos
	trp    -= cylinder.location;
	trp.yz *= rot2D(radians(cylinder.rotation.x));
	trp.xz *= rot2D(radians(cylinder.rotation.y));
	trp.xy *= rot2D(radians(cylinder.rotation.z));
	trp    /= cylinder.scale;

	vec2 d = abs(vec2(length(trp.xy), trp.z)) - vec2(cylinder.radius, cylinder.height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCylinder(ray_pos     , cylinder_pos, cylinder_radius, cylinder_height);
    float nx = signDistCylinder(ray_pos + dx, cylinder_pos, cylinder_radius, cylinder_height) - d;
    float ny = signDistCylinder(ray_pos + dy, cylinder_pos, cylinder_radius, cylinder_height) - d;
    float nz = signDistCylinder(ray_pos + dz, cylinder_pos, cylinder_radius, cylinder_height) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCylinder(vec3 ray_pos, inout Cylinder cylinder) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCylinder(ray_pos     , cylinder.location, cylinder.radius, cylinder.height);
    float nx = signDistCylinder(ray_pos + dx, cylinder.location, cylinder.radius, cylinder.height) - d;
    float ny = signDistCylinder(ray_pos + dy, cylinder.location, cylinder.radius, cylinder.height) - d;
    float nz = signDistCylinder(ray_pos + dz, cylinder.location, cylinder.radius, cylinder.height) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cone {
	vec3 location;
	float radius;

	vec3 rotation;
	float height;

	vec3 scale;
	int visible;

	int affectWorld;
	int type;
	int index;
	int material_type;

	int material_index;
};
float signDistCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base inout 2D
	float angle = atan(cone_radius / 2.0 / cone_height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone_height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_pos.xy - cone_pos.xy), ray_pos.z - cone_pos.z);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
float signDistCone(vec3 ray_pos, inout Cone cone) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base inout 2D

	vec3 trp = ray_pos; // transformed ray_pos
	trp    -= cone.location;
	trp.yz *= rot2D(radians(cone.rotation.x));
	trp.xz *= rot2D(radians(cone.rotation.y));
	trp.xy *= rot2D(radians(cone.rotation.z));
	trp    /= cone.scale;

	float angle = atan(cone.radius / 2.0 / cone.height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone.height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(trp.xy), trp.z);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
vec3 normalCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCone(ray_pos     , cone_pos, cone_radius, cone_height);
    float nx = signDistCone(ray_pos + dx, cone_pos, cone_radius, cone_height) - d;
    float ny = signDistCone(ray_pos + dy, cone_pos, cone_radius, cone_height) - d;
    float nz = signDistCone(ray_pos + dz, cone_pos, cone_radius, cone_height) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCone(vec3 ray_pos, inout Cone cone) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCone(ray_pos     , cone.location, cone.radius, cone.height);
    float nx = signDistCone(ray_pos + dx, cone.location, cone.radius, cone.height) - d;
    float ny = signDistCone(ray_pos + dy, cone.location, cone.radius, cone.height) - d;
    float nz = signDistCone(ray_pos + dz, cone.location, cone.radius, cone.height) - d;

    return normalize(vec3(nx, ny, nz));
}



struct Boolean {
	int selfObjType;
	int selfObjIndex;
	int otherObjType;
	int otherObjIndex;
		
	int type;
	float blend;
};
