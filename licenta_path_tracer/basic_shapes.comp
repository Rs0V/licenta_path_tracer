
float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}
float smoothUnion(float a, float b, float k) {
	float h = clamp(0.5 + (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) - k * h * (1.0 - h);
}
float smoothSubtraction(float a, float b, float k) {
	float h = clamp(0.5 - (b + a) / 2 / k, 0.0, 1.0);
	return mix(b, -a, h) + k * h * (1.0 - h);
}
float smoothIntersection(float a, float b, float k) {
	float h = clamp(0.5 - (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) + k * h * (1.0 - h);
}



struct Sphere {
	vec3 location;
	vec3 rotation;
	vec3 scale;

	float radius;

	vec4 color;
};
float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return distance(sphere_pos, ray_pos) - sphere_radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return normalize(ray_pos - sphere_pos);
}


struct Cube {
	vec3 location;
	vec3 rotation;
	vec3 scale;

	vec3 dimensions;

	vec4 color;
};
float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 q = abs(ray_pos - cube_pos) - dims / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 cubeToRay = ray_pos - cube_pos;
	vec3 dist = abs(cubeToRay) - dims / 2.0;
	return
		  dist.x < 0.001 ? vec3(sign(cubeToRay.x), 0.0, 0.0)
		: dist.y < 0.001 ? vec3(0.0, sign(cubeToRay.y), 0.0)
		: dist.z < 0.001 ? vec3(0.0, 0.0, sign(cubeToRay.z))
		: vec3(0.0)
	;
}


struct Cylinder {
	vec3 location;
	vec3 rotation;
	vec3 scale;

	float radius;
	float height;

	vec4 color;
};
/*
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return length(max(d, 0.0)) + max(min(d.x, 0.0), min(d.y, 0.0));
}
*/
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec2 d = abs(vec2(length(ray_pos.xz - cylinder_pos.xz), ray_pos.y - cylinder_pos.y)) - vec2(cylinder_radius, cylinder_height);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}


struct Cone {
	vec3 location;
	vec3 rotation;
	vec3 scale;

	float radius;
	float height;

	vec4 color;
};
float sdCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base in 2D
	float angle = atan(cone_radius / 2.0 / cone_height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone_height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_pos.xz - cone_pos.xz), ray_pos.y - cone_pos.y);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
