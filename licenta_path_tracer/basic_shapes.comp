
#include "/utils.comp" //! #include "./utils.comp"

float signDistRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_pos - cylinder_pos;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	if (abs(ray_pos.z - cylinder_pos.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_pos.z > cylinder_pos.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_pos - cylinder_pos).xy, 0.0));
}

float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}
float smoothUnion(float a, float b, float k) {
	float h = clamp(0.5 + (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) - k * h * (1.0 - h);
}
float smoothIntersect(float a, float b, float k) {
	float h = clamp(0.5 - (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) + k * h * (1.0 - h);
}
float smoothDifference(float a, float b, float k) {
	swap(a, b);
	float h = clamp(0.5 - (b + a) / 2 / k, 0.0, 1.0);
	return mix(b, -a, h) + k * h * (1.0 - h);
}



struct Sphere {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float pad3[3];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
	return distance(sphere_pos, ray_pos) - sphere_radius;
}
float signDistSphere(vec3 ray_pos, in Sphere sphere) {
	return distance(ray_pos / sphere.scale, sphere.location) - sphere.radius;
}
vec3 normalSphere(vec3 ray_pos, vec3 sphere_pos, float sphere_radius) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistSphere(ray_pos     , sphere_pos, sphere_radius);
    float nx = signDistSphere(ray_pos + dx, sphere_pos, sphere_radius) - d;
    float ny = signDistSphere(ray_pos + dy, sphere_pos, sphere_radius) - d;
    float nz = signDistSphere(ray_pos + dz, sphere_pos, sphere_radius) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cube {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	vec3 dimensions;
	float pad3;

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
	vec3 q = abs(ray_pos - cube_pos) - dims / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
float signDistCube(vec3 ray_pos, in Cube cube) {
	vec3 trp  = ray_pos / cube.scale; // transformed ray_pos
	trp *= rotateVector(normalize(trp), vec3(1.0, 0.0, 0.0), radians(cube.rotation.x));
	trp *= rotateVector(normalize(trp), vec3(0.0, 1.0, 0.0), radians(cube.rotation.y));
	trp *= rotateVector(normalize(trp), vec3(0.0, 0.0, 1.0), radians(cube.rotation.z));

	vec3 q = abs(trp - cube.location) - cube.dimensions / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
vec3 normalCube(vec3 ray_pos, vec3 cube_pos, vec3 dims) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCube(ray_pos     , cube_pos, dims);
    float nx = signDistCube(ray_pos + dx, cube_pos, dims) - d;
    float ny = signDistCube(ray_pos + dy, cube_pos, dims) - d;
    float nz = signDistCube(ray_pos + dz, cube_pos, dims) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cylinder {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float pad3[3];

	float height;
	float pad4[3];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
	vec2 d = abs(vec2(length(ray_pos.xy - cylinder_pos.xy), ray_pos.z - cylinder_pos.z)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
float signDistCylinder(vec3 ray_pos, in Cylinder cylinder) {
	vec2 d = abs(vec2(length(ray_pos.xy / cylinder.scale.xy - cylinder.location.xy), ray_pos.z / cylinder.scale.z - cylinder.location.z)) - vec2(cylinder.radius, cylinder.height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalCylinder(vec3 ray_pos, vec3 cylinder_pos, float cylinder_radius, float cylinder_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCylinder(ray_pos     , cylinder_pos, cylinder_radius, cylinder_height);
    float nx = signDistCylinder(ray_pos + dx, cylinder_pos, cylinder_radius, cylinder_height) - d;
    float ny = signDistCylinder(ray_pos + dy, cylinder_pos, cylinder_radius, cylinder_height) - d;
    float nz = signDistCylinder(ray_pos + dz, cylinder_pos, cylinder_radius, cylinder_height) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cone {
	vec3 location;
	float pad0;

	vec3 rotation;
	float pad1;

	vec3 scale;
	float pad2;

	float radius;
	float pad3[3];

	float height;
	float pad4[3];

	vec4 color;

	int booleanObjType;
	int booleanObjIndex;
	int booleanType;

	int visible;
};
float signDistCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base in 2D
	float angle = atan(cone_radius / 2.0 / cone_height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone_height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_pos.xy - cone_pos.xy), ray_pos.z - cone_pos.z);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
float signDistCone(vec3 ray_pos, in Cone cone) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base in 2D
	float angle = atan(cone.radius / 2.0 / cone.height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone.height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_pos.xy / cone.scale.xy - cone.location.xy), ray_pos.z / cone.scale.z - cone.location.z);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
vec3 normalCone(vec3 ray_pos, vec3 cone_pos, float cone_radius, float cone_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCone(ray_pos     , cone_pos, cone_radius, cone_height);
    float nx = signDistCone(ray_pos + dx, cone_pos, cone_radius, cone_height) - d;
    float ny = signDistCone(ray_pos + dy, cone_pos, cone_radius, cone_height) - d;
    float nz = signDistCone(ray_pos + dz, cone_pos, cone_radius, cone_height) - d;

    return normalize(vec3(nx, ny, nz));
}
