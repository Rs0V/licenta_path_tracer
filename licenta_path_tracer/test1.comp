#version 450 core
#extension GL_ARB_shading_language_include : require
#include "/basic_shapes.comp" //! #include "./basic_shapes.comp"
vec3 rgb2hsv(vec3 color) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(color.bg, K.wz), vec4(color.gb, K.xy), step(color.b, color.g));
    vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv2rgb(vec3 color) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);
    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);
}

vec3 hueShift(vec3 color, float hue) {
    vec3 hsv = rgb2hsv(color);
    hsv.x = mod(hsv.x + hue / 360.0, 1.0);
    return hsv2rgb(hsv);
}
vec3 saturationMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.y *= factor;
    return hsv2rgb(hsv);
}
vec3 valueMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.z *= factor;
    return hsv2rgb(hsv);
}


vec3 tangent(vec3 v) {
	vec3 arbx = vec3(1.0, 0.0, 0.0);
	vec3 arby = vec3(0.0, 1.0, 0.0);
	vec3 arbz = vec3(0.0, 0.0, 1.0);

	vec3 arbitrary = v.x < v.y ? (v.x < v.z ? arbx : arbz) : v.y < v.z ? arby : arbz;
	return normalize(cross(v, arbitrary));
}

float angle(vec3 a, vec3 b) {
	return acos(dot(a, b) / (length(a) * length(b)));
}


float random(float value) {
	return fract(sqrt(value * 129.898) + 100.001 / 7.69 * 43758.5453);
}
vec3 rotateVector(vec3 v, vec3 axis, float angle) {
	// Rodrigues' rotation formula
	return mix(dot(axis, v) * axis, v, cos(angle)) + cross(axis, v) * sin(angle);
}
vec3 diffuseVector(vec3 v, vec3 normal, float maxAngle) {
	float randomAngleX = random(dot(v, normal) * maxAngle + 12.68) * maxAngle - maxAngle / 2.0;
	float randomAngleY = random(dot(v, normal) * maxAngle + 41.01) * maxAngle - maxAngle / 2.0;
	float randomAngleZ = random(dot(v, normal) * maxAngle + 65.32) * maxAngle - maxAngle / 2.0;

	vec3 tg = tangent(normal);

	vec3 rotZ = rotateVector(v, normal, randomAngleZ);
	vec3 rotY = rotateVector(rotZ, tg, randomAngleY);
	vec3 rotX = rotateVector(rotY, normalize(cross(normal, tg)), randomAngleX);

	return normalize(mix(normal, rotX, 0.66));
}

mat2 rot2D(float angle) {
	float s = sin(angle);
	float c = cos(angle);
	return mat2(c, -s, s, c);
}


uint packColor(vec4 color) {
	return uint(color.r * 255.0) << 24 |
		   uint(color.g * 255.0) << 16 |
		   uint(color.b * 255.0) <<  8 |
		   uint(color.a * 255.0);
}
vec4 unpackColor(uint packedColor) {
	return vec4(
		float((packedColor >> 24) & 0xFF) / 255.0,
		float((packedColor >> 16) & 0xFF) / 255.0,
		float((packedColor >>  8) & 0xFF) / 255.0,
		float( packedColor        & 0xFF) / 255.0
	);
}


#define m_mulAdd(type) type mulAdd(type a, type base) { \
	return fma(a, base, a); \
}
m_mulAdd(float)
m_mulAdd(double)
m_mulAdd(vec2)
m_mulAdd(vec3)
m_mulAdd(vec4)


#define m_swap(type) void swap(inout type a, inout type b) { \
    type temp = a; \
    a = b; \
    b = temp; \
}
m_swap(int)
m_swap(uint)
m_swap(float)
m_swap(double)
m_swap(vec2)
m_swap(vec3)
m_swap(vec4)



const float pi = 3.14159;
const float rpi = 0.31831;


float signDistRingCylinder(vec3 ray_loc, vec3 cylinder_loc, float cylinder_radius, float cylinder_height) {
	vec3 p = ray_loc - cylinder_loc;
	vec2 d = abs(vec2(length(p.xy) - cylinder_radius, p.z)) - vec2(cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalRingCylinder(vec3 ray_loc, vec3 cylinder_loc, float cylinder_radius, float cylinder_height) {
	if (abs(ray_loc.z - cylinder_loc.z) - cylinder_height / 2.0 < 0.001) {
		return vec3(0.0, 0.0, (ray_loc.z > cylinder_loc.z) ? 1.0 : -1.0);
	}
	return normalize(vec3((ray_loc - cylinder_loc).xy, 0.0));
}

float smoothMin(float a, float b, float k) {
	float h = max(k - abs(a - b), 0) / k;
	return min(a, b) - pow(h, 3) * k / 6.0;
}
float smoothUnion(float a, float b, float k) {
	float h = clamp(0.5 + (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) - k * h * (1.0 - h);
}
float smoothIntersect(float a, float b, float k) {
	float h = clamp(0.5 - (b - a) / 2 / k, 0.0, 1.0);
	return mix(b, a, h) + k * h * (1.0 - h);
}
float smoothDifference(float a, float b, float k) {
	swap(a, b);
	float h = clamp(0.5 - (b + a) / 2 / k, 0.0, 1.0);
	return mix(b, -a, h) + k * h * (1.0 - h);
}



struct Sphere {
	vec3 location;
	int visible;

	vec3 rotation;
	int affectWorld;

	vec3 scale;
	float radius;

	int type;
	int index;
	int material_type;
	int material_index;
};
float signDistSphere(vec3 ray_loc, vec3 sphere_loc, float sphere_radius) {
	return distance(sphere_loc, ray_loc) - sphere_radius;
}
float signDistSphere(vec3 ray_loc, inout Sphere sphere) {
	vec3 trp = ray_loc; // transformed ray_loc
	trp    -= sphere.location;
	trp.yz *= rot2D(radians(sphere.rotation.x));
	trp.xz *= rot2D(radians(sphere.rotation.y));
	trp.xy *= rot2D(radians(sphere.rotation.z));
	trp    /= sphere.scale;

	return length(trp) - sphere.radius;
}
vec3 normalSphere(vec3 ray_loc, vec3 sphere_loc, float sphere_radius) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistSphere(ray_loc     , sphere_loc, sphere_radius);
    float nx = signDistSphere(ray_loc + dx, sphere_loc, sphere_radius) - d;
    float ny = signDistSphere(ray_loc + dy, sphere_loc, sphere_radius) - d;
    float nz = signDistSphere(ray_loc + dz, sphere_loc, sphere_radius) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalSphere(vec3 ray_loc, inout Sphere sphere) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistSphere(ray_loc     , sphere.location, sphere.radius);
    float nx = signDistSphere(ray_loc + dx, sphere.location, sphere.radius) - d;
    float ny = signDistSphere(ray_loc + dy, sphere.location, sphere.radius) - d;
    float nz = signDistSphere(ray_loc + dz, sphere.location, sphere.radius) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cube {
	vec3 location;
	int visible;

	vec3 rotation;
	int affectWorld;

	vec3 scale;
	int material_type;

	vec3 dimensions;
	int material_index;

	int type;
	int index;
};
float signDistCube(vec3 ray_loc, vec3 cube_loc, vec3 dims) {
	vec3 q = abs(ray_loc - cube_loc) - dims / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
float signDistCube(vec3 ray_loc, inout Cube cube) {
	vec3 trp = ray_loc; // transformed ray_loc
	trp    -= cube.location;
	trp.yz *= rot2D(radians(cube.rotation.x));
	trp.xz *= rot2D(radians(cube.rotation.y));
	trp.xy *= rot2D(radians(cube.rotation.z));
	trp    /= cube.scale;

	vec3 q = abs(trp) - cube.dimensions / 2.0;
	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}
vec3 normalCube(vec3 ray_loc, vec3 cube_loc, vec3 dims) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCube(ray_loc     , cube_loc, dims);
    float nx = signDistCube(ray_loc + dx, cube_loc, dims) - d;
    float ny = signDistCube(ray_loc + dy, cube_loc, dims) - d;
    float nz = signDistCube(ray_loc + dz, cube_loc, dims) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCube(vec3 ray_loc, inout Cube cube) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCube(ray_loc     , cube.location, cube.dimensions);
    float nx = signDistCube(ray_loc + dx, cube.location, cube.dimensions) - d;
    float ny = signDistCube(ray_loc + dy, cube.location, cube.dimensions) - d;
    float nz = signDistCube(ray_loc + dz, cube.location, cube.dimensions) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cylinder {
	vec3 location;
	float radius;

	vec3 rotation;
	float height;

	vec3 scale;
	int visible;

	int affectWorld;
	int type;
	int index;
	int material_type;

	int material_index;
};
float signDistCylinder(vec3 ray_loc, vec3 cylinder_loc, float cylinder_radius, float cylinder_height) {
	vec2 d = abs(vec2(length(ray_loc.xz - cylinder_loc.xz), ray_loc.y - cylinder_loc.y)) - vec2(cylinder_radius, cylinder_height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
float signDistCylinder(vec3 ray_loc, inout Cylinder cylinder) {
	vec3 trp = ray_loc; // transformed ray_loc
	trp    -= cylinder.location;
	trp.yz *= rot2D(radians(cylinder.rotation.x));
	trp.xz *= rot2D(radians(cylinder.rotation.y));
	trp.xy *= rot2D(radians(cylinder.rotation.z));
	trp    /= cylinder.scale;

	vec2 d = abs(vec2(length(trp.xz), trp.y)) - vec2(cylinder.radius, cylinder.height / 2.0);
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}
vec3 normalCylinder(vec3 ray_loc, vec3 cylinder_loc, float cylinder_radius, float cylinder_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCylinder(ray_loc     , cylinder_loc, cylinder_radius, cylinder_height);
    float nx = signDistCylinder(ray_loc + dx, cylinder_loc, cylinder_radius, cylinder_height) - d;
    float ny = signDistCylinder(ray_loc + dy, cylinder_loc, cylinder_radius, cylinder_height) - d;
    float nz = signDistCylinder(ray_loc + dz, cylinder_loc, cylinder_radius, cylinder_height) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCylinder(vec3 ray_loc, inout Cylinder cylinder) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCylinder(ray_loc     , cylinder.location, cylinder.radius, cylinder.height);
    float nx = signDistCylinder(ray_loc + dx, cylinder.location, cylinder.radius, cylinder.height) - d;
    float ny = signDistCylinder(ray_loc + dy, cylinder.location, cylinder.radius, cylinder.height) - d;
    float nz = signDistCylinder(ray_loc + dz, cylinder.location, cylinder.radius, cylinder.height) - d;

    return normalize(vec3(nx, ny, nz));
}


struct Cone {
	vec3 location;
	float radius;

	vec3 rotation;
	float height;

	vec3 scale;
	int visible;

	int affectWorld;
	int type;
	int index;
	int material_type;

	int material_index;
};
float signDistCone(vec3 ray_loc, vec3 cone_loc, float cone_radius, float cone_height) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base inout 2D
	float angle = atan(cone_radius / 2.0 / cone_height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone_height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(ray_loc.xz - cone_loc.xz), ray_loc.y - cone_loc.y);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
float signDistCone(vec3 ray_loc, inout Cone cone) {
	// c is the sin/cos of the angle, h is height
	// Alternatively pass q instead of (c,h),
	// which is the point at the base inout 2D

	vec3 trp = ray_loc; // transformed ray_loc
	trp    -= cone.location;
	trp.yz *= rot2D(radians(cone.rotation.x));
	trp.xz *= rot2D(radians(cone.rotation.y));
	trp.xy *= rot2D(radians(cone.rotation.z));
	trp    /= cone.scale;

	float angle = atan(cone.radius / 2.0 / cone.height) * 2.0;
	vec2 c = vec2(sin(angle), cos(angle));

	vec2 q = cone.height * vec2(c.x / c.y, -1.0);
	vec2 w = vec2(length(trp.xz), trp.y);
	vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);
	vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);
	float k = sign(q.y);
	float d = min(dot(a, a), dot(b, b));
	float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));
	return sqrt(d) * sign(s);
}
vec3 normalCone(vec3 ray_loc, vec3 cone_loc, float cone_radius, float cone_height) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCone(ray_loc     , cone_loc, cone_radius, cone_height);
    float nx = signDistCone(ray_loc + dx, cone_loc, cone_radius, cone_height) - d;
    float ny = signDistCone(ray_loc + dy, cone_loc, cone_radius, cone_height) - d;
    float nz = signDistCone(ray_loc + dz, cone_loc, cone_radius, cone_height) - d;

    return normalize(vec3(nx, ny, nz));
}
vec3 normalCone(vec3 ray_loc, inout Cone cone) {
    float epsilon = 0.0001;
    vec3 dx = vec3(epsilon, 0.0, 0.0);
    vec3 dy = vec3(0.0, epsilon, 0.0);
    vec3 dz = vec3(0.0, 0.0, epsilon);

    float d  = signDistCone(ray_loc     , cone.location, cone.radius, cone.height);
    float nx = signDistCone(ray_loc + dx, cone.location, cone.radius, cone.height) - d;
    float ny = signDistCone(ray_loc + dy, cone.location, cone.radius, cone.height) - d;
    float nz = signDistCone(ray_loc + dz, cone.location, cone.radius, cone.height) - d;

    return normalize(vec3(nx, ny, nz));
}



struct Boolean {
	int selfObjType;
	int selfObjIndex;
	int otherObjType;
	int otherObjIndex;
		
	int type;
	float blend;
};

struct PrincipledBSDF {
	vec3 albedo;
	float metallic;

	float roughness;
	float ior;
	float reflectance;
	float transmission;

	vec4 emissive;
};

struct VolumeScatter {
	vec3 color;
	float density;

	float diameter;
};

struct PointLight {
	vec3 location;
	float intensity;

	vec3 color;
	float radius;
};


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D img_output;
uniform uvec2 tile_offset;



//  0 - accumulate samples;
//  1 - rendered frame only
// -1 - reset image buffer
uniform int scene_change = 0;

uniform mat4 camera_proj;
uniform mat4 camera_view;
uniform vec3 camera_loc;

uniform float random_f01;
uniform int samples;

const float hitThreshold = 0.001;
const float farPlane = 10000.0;

uniform sampler2D blueNoise;



#define spheres_no 100
#define cubes_no 100
#define cylinders_no 100
#define cones_no 100
#define booleans_no 100
#define point_lights_no 100
#define principled_bsdfs_no 100
#define volume_scatters_no 100
layout (std430, binding = 1) buffer BasicShapes {
	Sphere spheres[spheres_no];
	Cube cubes[cubes_no];
	Cylinder cylinders[cylinders_no];
	Cone cones[cones_no];
	Boolean booleans[booleans_no];
};
layout (std430, binding = 2) buffer Props {
	PointLight point_lights[point_lights_no];
	PrincipledBSDF principled_bsdfs[principled_bsdfs_no];
	VolumeScatter volume_scatters[volume_scatters_no];
};



struct RaycastHit {
	bool hit;
	vec3 location;
	vec3 direction;
	vec3 normal;

	int obj_type;
	int obj_index;

	int material_type;
	int material_index;
};

float signDistBlendedObj(float obj_dist_1, float obj_dist_2, int booleanType = -1, float blend = 0.5) {
	switch(booleanType) {
	case -1:
		return min(obj_dist_1, obj_dist_2);
	case 0:
		return smoothUnion(obj_dist_1, obj_dist_2, blend);
	case 1:
		return smoothIntersect(obj_dist_1, obj_dist_2, blend);
	case 2:
		return smoothDifference(obj_dist_1, obj_dist_2, blend);
	}
}

float signDistObj(vec3 ray_loc, int obj_type, int obj_index) {
	switch(obj_type) {
	case 0:
		return signDistSphere(ray_loc, spheres[obj_index]);
	case 1:
		return signDistCube(ray_loc, cubes[obj_index]);
	case 2:
		return signDistCylinder(ray_loc, cylinders[obj_index]);
	case 3:
		return signDistCone(ray_loc, cones[obj_index]);
	}
	return -999999999;
}
vec3 normalObj(vec3 ray_loc, int obj_type, int obj_index) {
	const float epsilon = 0.001;
	const mat3x3 d = mat3x3(
		vec3(epsilon, 0, 0),
		vec3(0, epsilon, 0),
		vec3(0, 0, epsilon)
	);


	float cd = signDistObj(ray_loc, obj_type, obj_index);
	for (int j = 0; j < booleans_no; j++) {
		if (booleans[j].selfObjType == obj_type && booleans[j].selfObjIndex == obj_index) {
			float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
			cd = signDistBlendedObj(cd, distToOther, booleans[j].type, booleans[j].blend);
		}
	}

	float d0 = signDistObj(ray_loc + d[0], obj_type, obj_index);
	for (int j = 0; j < booleans_no; j++) {
		if (booleans[j].selfObjType == obj_type && booleans[j].selfObjIndex == obj_index) {
			float distToOther = signDistObj(ray_loc + d[0], booleans[j].otherObjType, booleans[j].otherObjIndex);
			d0 = signDistBlendedObj(d0, distToOther, booleans[j].type, booleans[j].blend);
		}
	}
	float d1 = signDistObj(ray_loc + d[1], obj_type, obj_index);
	for (int j = 0; j < booleans_no; j++) {
		if (booleans[j].selfObjType == obj_type && booleans[j].selfObjIndex == obj_index) {
			float distToOther = signDistObj(ray_loc + d[1], booleans[j].otherObjType, booleans[j].otherObjIndex);
			d1 = signDistBlendedObj(d1, distToOther, booleans[j].type, booleans[j].blend);
		}
	}
	float d2 = signDistObj(ray_loc + d[2], obj_type, obj_index);
	for (int j = 0; j < booleans_no; j++) {
		if (booleans[j].selfObjType == obj_type && booleans[j].selfObjIndex == obj_index) {
			float distToOther = signDistObj(ray_loc + d[2], booleans[j].otherObjType, booleans[j].otherObjIndex);
			d2 = signDistBlendedObj(d2, distToOther, booleans[j].type, booleans[j].blend);
		}
	}


	return normalize((vec3(d0, d1, d2) - cd) / epsilon);
}

float signDistScene(vec3 ray_loc) {
	float minDist = 999999999;

	// Check for closest Sphere
	for (int i = 0; i < spheres_no; i++) {
		if (spheres[i].visible == 0) {
			continue;
		}

		float closest = signDistSphere(ray_loc, spheres[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 0 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}

	// Check for closest Cube
	for (int i = 0; i < cubes_no; i++) {
		if (cubes[i].visible == 0) {
			continue;
		}

		float closest = signDistCube(ray_loc, cubes[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 1 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}
	
	// Check for closest Cylinder
	for (int i = 0; i < cylinders_no; i++) {
		if (cylinders[i].visible == 0) {
			continue;
		}

		float closest = signDistCylinder(ray_loc, cylinders[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 2 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}
	
	// Check for closest Cone
	for (int i = 0; i < cones_no; i++) {
		if (cones[i].visible == 0) {
			continue;
		}

		float closest = signDistCone(ray_loc, cones[i]);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == 3 && booleans[j].selfObjIndex == i) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (closest < minDist) {
			minDist = closest;
		}
	}

	return minDist;
}
vec3 normalScene(vec3 ray_loc) {
	const float epsilon = 0.001;
	const mat3x3 d = mat3x3(
		vec3(epsilon, 0, 0),
		vec3(0, epsilon, 0),
		vec3(0, 0, epsilon)
	);

	float cd = signDistScene(ray_loc);
	return normalize((vec3(signDistScene(ray_loc + d[0]), signDistScene(ray_loc + d[1]), signDistScene(ray_loc + d[2])) - cd) / epsilon);
}


RaycastHit raycast(vec3 ray_loc, vec3 ray_dir) {
	vec3 init_loc = ray_loc;
	ray_loc += ray_dir * hitThreshold * 100.0;

	int obj_type = -1; // 0 - sphere, 1 - cube, 2 - cylinder, 3 - cone
	int obj_index = -1;
	float minimumDistance = 999999999;
	float mDepsDistMin = 0.5;
	float mDepsDistDiff = 0.1;
	int mDeqCount = 0;
	while (distance(init_loc, ray_loc) < farPlane) {
		float minDist = 999999999;

		// Check for closest Sphere
		for (int i = 0; i < spheres_no; i++) {
			if (spheres[i].visible == 0) {
				continue;
			}

			float closest = signDistSphere(ray_loc, spheres[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 0 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type  = 0;
				obj_index = i;
			}
		}

		// Check for closest Cube
		for (int i = 0; i < cubes_no; i++) {
			if (cubes[i].visible == 0) {
				continue;
			}

			float closest = signDistCube(ray_loc, cubes[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 1 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 1;
				obj_index = i;
			}
		}
		
		// Check for closest Cylinder
		for (int i = 0; i < cylinders_no; i++) {
			if (cylinders[i].visible == 0) {
				continue;
			}

			float closest = signDistCylinder(ray_loc, cylinders[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 2 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 2;
				obj_index = i;
			}
		}
		
		// Check for closest Cone
		for (int i = 0; i < cones_no; i++) {
			if (cones[i].visible == 0) {
				continue;
			}

			float closest = signDistCone(ray_loc, cones[i]);
			for (int j = 0; j < booleans_no; j++) {
				if (booleans[j].selfObjType == 3 && booleans[j].selfObjIndex == i) {
					float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
					closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
				}
			}

			if (closest < minDist) {
				minDist = closest;
				obj_type = 3;
				obj_index = i;
			}
		}
		
		
		// Minimum distance aproximation for better performance
		// when tracing against parallel surfaces
		if (distance(minimumDistance, minDist) < mDepsDistDiff && minDist < mDepsDistMin) {
			minDist *= pow(2, mDeqCount + 1);
			mDeqCount++;
		} else {
			minimumDistance = minDist;
			mDeqCount = 0;
		}
		ray_loc += ray_dir * minDist;


		if (minDist < hitThreshold) {
			int mat_type =
				  obj_type == 0 ? spheres[obj_index].material_type
				: obj_type == 1 ? cubes[obj_index].material_type
				: obj_type == 2 ? cylinders[obj_index].material_type
				: obj_type == 3 ? cones[obj_index].material_type
				: -1
			;
			int mat_index =
				  obj_type == 0 ? spheres[obj_index].material_index
				: obj_type == 1 ? cubes[obj_index].material_index
				: obj_type == 2 ? cylinders[obj_index].material_index
				: obj_type == 3 ? cones[obj_index].material_index
				: -1
			;

			return RaycastHit(true, ray_loc, ray_dir, normalObj(ray_loc, obj_type, obj_index), obj_type, obj_index, mat_type, mat_index);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), -1, -1, -1, -1);
}
RaycastHit raycast_transmissive(vec3 ray_loc, vec3 ray_dir, int obj_type, int obj_index) {
	vec3 init_loc = ray_loc;
	ray_loc += ray_dir * hitThreshold * 100.0;

	while (distance(init_loc, ray_loc) < farPlane) {
		float closest = signDistObj(ray_loc, obj_type, obj_index);
		for (int j = 0; j < booleans_no; j++) {
			if (booleans[j].selfObjType == obj_type && booleans[j].selfObjIndex == obj_index) {
				float distToOther = signDistObj(ray_loc, booleans[j].otherObjType, booleans[j].otherObjIndex);
				closest = signDistBlendedObj(closest, distToOther, booleans[j].type, booleans[j].blend);
			}
		}

		if (abs(closest) < hitThreshold || closest > 0.0) {
			ray_loc += ray_dir * hitThreshold * 100.0;

			int mat_type =
				  obj_type == 0 ? spheres[obj_index].material_type
				: obj_type == 1 ? cubes[obj_index].material_type
				: obj_type == 2 ? cylinders[obj_index].material_type
				: obj_type == 3 ? cones[obj_index].material_type
				: -1
			;
			int mat_index =
				  obj_type == 0 ? spheres[obj_index].material_index
				: obj_type == 1 ? cubes[obj_index].material_index
				: obj_type == 2 ? cylinders[obj_index].material_index
				: obj_type == 3 ? cones[obj_index].material_index
				: -1
			;

			return RaycastHit(true, ray_loc, ray_dir, normalObj(ray_loc, obj_type, obj_index), obj_type, obj_index, mat_type, mat_index);
		}

		ray_loc += ray_dir * abs(closest);
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), -1, -1, -1, -1);
}

RaycastHit raycast_light(vec3 ray_loc, vec3 ray_dir, inout PointLight point_light) {
	vec3 init_loc = ray_loc;
	ray_loc += ray_dir * hitThreshold * 100.0;

	while (distance(init_loc, ray_loc) < farPlane) {
		float minDist = 999999999;
		float temp = min(minDist, signDistSphere(ray_loc, point_light.location, point_light.radius));
		if (temp < minDist) {
			minDist = temp;
		}
		ray_loc += ray_dir * minDist;
		
		if (minDist < hitThreshold) {
			vec3 normal = normalSphere(ray_loc, point_light.location, point_light.radius);
			return RaycastHit(true, ray_loc, ray_dir, normal, -1, -1, -1, -1);
		}
	}

	return RaycastHit(false, vec3(0.0), vec3(0.0), vec3(0.0), -1, -1, -1, -1);
}

RaycastHit reflectRay(inout RaycastHit ray, vec3 normal = vec3(0.0)) {
	vec3 N = (normal.x + normal.y + normal.z > 0.001) ? normal : ray.normal;
	return RaycastHit(
		ray.hit,
		ray.location,
		normalize(reflect(normalize(ray.direction), normalize(N))),
		N,
		ray.obj_type,
		ray.obj_index,
		ray.material_type,
		ray.material_index
	);
}
RaycastHit refractRay1(inout RaycastHit ray, float ior_exit, float ior_enter) {
	return RaycastHit(
		ray.hit,
		ray.location,
		normalize(refract(normalize(ray.direction), normalize(ray.normal), ior_exit / ior_enter)),
		ray.normal,
		ray.obj_type,
		ray.obj_index,
		ray.material_type,
		ray.material_index
	);
}
RaycastHit refractRay(inout RaycastHit ray, float ior_obj, vec3 normal = vec3(0.0), float ior_env = 1.0) {
	bool enter = dot(ray.direction, ray.normal) < 0.0;
	vec3 N = (normal.x + normal.y + normal.z > 0.001) ? normal : ray.normal;
	return RaycastHit(
		ray.hit,
		ray.location,
		normalize(ray.direction - reflect((enter ? 1.0 : -1.0) * ray.direction, N) * (enter ? ior_obj / ior_env : ior_env / ior_obj)),
		N,
		ray.obj_type,
		ray.obj_index,
		ray.material_type,
		ray.material_index
	);
}



float random(vec2 uv) {
	return texture(blueNoise, uv + vec2(random_f01, fract(random_f01 * 7.931199))).x;
}
vec3 randomVectorInSphericalCap(vec2 uv, vec3 normal, float max_angle, bool signedSpread = true) {
	vec3 tg1  = tangent(normal);
	vec3 tg2  = normalize(cross(normal, tg1));

	float min_angle = signedSpread ? -max_angle / 2.0 : 0.0;
	max_angle       = signedSpread ?  max_angle / 2.0 : max_angle;

	float theta1 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.000, 0.543)));
	float theta2 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.341, 0.121)));
	float theta3 = mix(radians(min_angle), radians(max_angle), random(uv + vec2(0.859, 0.652)));

	vec3 rot1 = rotateVector(normal, tg1,    theta1);
	vec3 rot2 = rotateVector(rot1,   tg2,    theta2);
	vec3 rot3 = rotateVector(rot2,   normal, theta3);
	
	return rot3;
}
vec3 randomVectorInHemisphere(vec2 uv, vec3 normal) {
	return randomVectorInSphericalCap(uv, normal, 180.0);
}


vec3 fresnel_schlick(float cos_theta, vec3 F0) {
	return F0 + (1.0 - F0) * pow(1.0 - cos_theta, 5.0);
}
float ndf_ggx(vec3 normal, vec3 half_vector, float roughness) {
	float r2 = roughness * roughness;
	float NdotH = max(dot(normal, half_vector), 0.0);
	float NdotH2 = NdotH * NdotH;

	float denominator = (NdotH2 * (r2 - 1.0) + 1.0);
	return r2 / (pi * denominator * denominator);
}
float geometry_schlick_ggx(float NdotV, float roughness) {
	float r = (roughness + 1.0);
	float k = (r * r) / 8.0;
	return NdotV / (NdotV * (1.0 - k) + k);
}
float geometry_smith(vec3 normal, vec3 view_dir, vec3 light_dir, float roughness) {
	float NdotV = max(dot(normal, view_dir), 0.0);
	float NdotL = max(dot(normal, light_dir), 0.0);
	float ggx1 = geometry_schlick_ggx(NdotV, roughness);
	float ggx2 = geometry_schlick_ggx(NdotL, roughness);
	return ggx1 * ggx2;
}

vec3 generate_diffuse_ray(vec2 uv, inout RaycastHit hit) {
	float rdisp = fract((hit.location.x + hit.location.y + hit.location.z) * 23.49789);
	return randomVectorInHemisphere(uv + vec2(rdisp, fract(rdisp * 3.65243)), hit.normal);
}
vec3 generate_glossy_ray(vec2 uv, inout RaycastHit hit, float roughness) {
	float rdisp = fract((hit.location.x + hit.location.y + hit.location.z) * 19.62173);
	vec3 randomRay = randomVectorInHemisphere(uv + vec2(rdisp, fract(rdisp * 1.722459)), hit.normal);
	vec3 idealRay  = reflectRay(hit).direction;
	return normalize(mix(idealRay, randomRay, roughness));
}
vec3 generate_transmission_ray(vec2 uv, inout RaycastHit hit, float roughness, float ior_exit, float ior_enter) {
	float rdisp = fract((hit.location.x + hit.location.y + hit.location.z) * 37.43111);
	vec3 randomRay = randomVectorInHemisphere(uv + vec2(rdisp, fract(rdisp * 5.652919)), hit.normal);
	vec3 idealRay  = refractRay(hit, ior_exit, ior_enter).direction;
	return normalize(mix(idealRay, randomRay, roughness));
}

vec3 lambertian_shading(inout RaycastHit hit, inout PointLight point_light) {
	vec3 light_dir = normalize(point_light.location - hit.location);

	float light_dist = distance(point_light.location, hit.location);
	float light_attenuation = 1.0 / (0.8 + 0.1 * light_dist + 0.03 * light_dist * light_dist);
	float light_intensity = point_light.intensity * light_attenuation;

	float diffuse_intensity = max(dot(hit.normal, light_dir), 0.0) * light_intensity;
	vec3 diffuse_color = principled_bsdfs[hit.material_index].albedo * point_light.color * diffuse_intensity;
	return diffuse_color;
}
vec3 cook_torrance_brdf(inout RaycastHit hit, inout PointLight point_light) {
	vec3 light_dir = normalize(point_light.location - hit.location);
	vec3 view_dir = normalize(camera_loc - hit.location);
	vec3 half_vector = normalize(view_dir + light_dir);

	vec3 F0 = mix(vec3(0.04), vec3(principled_bsdfs[hit.material_index].reflectance), principled_bsdfs[hit.material_index].metallic);

	float NDF = ndf_ggx(hit.normal, half_vector, principled_bsdfs[hit.material_index].roughness);
	float G = geometry_smith(hit.normal, view_dir, light_dir, principled_bsdfs[hit.material_index].roughness);
	vec3 F = fresnel_schlick(dot(hit.normal, half_vector), F0);

	float denominator = 4.0 * max(dot(hit.normal, view_dir), 0.0) * max(dot(hit.normal, light_dir), 0.0);
	vec3 specular = (NDF * G * F) / max(denominator, 0.001);

	vec3 kS = F;
	vec3 kD = vec3(1.0) - kS;
	kD *= 1.0 - principled_bsdfs[hit.material_index].metallic;

	float light_dist = distance(point_light.location, hit.location);
	float light_attenuation = 1.0 / (0.8 + 0.1 * light_dist + 0.03 * light_dist * light_dist);
	float light_intensity = point_light.intensity * light_attenuation;

	float NdotL = max(dot(hit.normal, light_dir), 0.0);
	return (kD * principled_bsdfs[hit.material_index].albedo + specular * light_intensity) * NdotL;
}

vec3 pbr_shading(inout RaycastHit hit, inout PointLight point_light) {
	vec3 vdiffuse = lambertian_shading(hit, point_light);
	vec3 vspecular = cook_torrance_brdf(hit, point_light);

	return vdiffuse * vspecular;
}


vec3 reflect_lambert(vec2 uv, inout RaycastHit ray) {
	float theta = pi * 2 * random(uv + vec2(0.81321, 0.543199));
	float u     = 2.0 * random(uv + vec2(0.3214666, 0.987522)) - 1.0;
	float r     = sqrt(1.0 - u * u);
	return normalize(ray.normal + vec3(r * cos(theta), r * sin(theta), u));
}





void createOrthonormalBasis(in vec3 N, out vec3 tangent, out vec3 bitangent) {
	vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	tangent = normalize(cross(up, N));
	bitangent = cross(N, tangent);
}


vec3 lambertianBRDF(in vec3 albedo) {
	return albedo / pi;
}


float DistributionGGX(float NdotH, float roughness) {
	float a = roughness * roughness;
	float a2 = a * a;
	float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);
	return a2 / (pi * denom * denom);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
	float r = roughness + 1.0;
	float k = (r * r) / 8.0;
	return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(in vec3 N, in vec3 V, in vec3 L, float roughness) {
	float NdotV = max(dot(N, V), 0.0);
	float NdotL = max(dot(N, L), 0.0);
	float ggxV = GeometrySchlickGGX(NdotV, roughness);
	float ggxL = GeometrySchlickGGX(NdotL, roughness);
	return ggxV * ggxL;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
	return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 cookTorranceBRDF(in vec3 N, in vec3 V, in vec3 L, float roughness, in vec3 F0) {
	vec3 H = normalize(V + L);
	float NdotL = max(dot(N, L), 0.0);
	float NdotV = max(dot(N, V), 0.0);
	float NdotH = max(dot(N, H), 0.0);
	float VdotH = max(dot(V, H), 0.0);
	
	float D = DistributionGGX(NdotH, roughness);
	float G = GeometrySmith(N, V, L, roughness);
	vec3 F = fresnelSchlick(VdotH, F0);
	
	vec3 specular = (D * G * F) / (4.0 * NdotV * NdotL + 0.0001);
	return specular;
}


vec3 sampleCosineWeightedDirection(in vec3 N, float rand1, float rand2) {
	float r = sqrt(rand1);
	float theta = 2.0 * pi * rand2;
	float x = r * cos(theta);
	float y = r * sin(theta);
	float z = sqrt(1.0 - rand1);
	
	vec3 tangent, bitangent;
	createOrthonormalBasis(N, tangent, bitangent);
	
	return normalize(x * tangent + y * bitangent + z * N);
}

float pdfDiffuse(in vec3 N, in vec3 sampleDir) {
	float cosine = max(dot(N, sampleDir), 0.0);
	return cosine / pi;
}


vec3 sampleGGXDirection(in vec3 N, in vec3 V, float roughness, float rand1, float rand2) {
	float a = roughness * roughness;
	float phi = 2.0 * pi * rand1;
	float cosTheta = sqrt((1.0 - rand2) / (1.0 + (a * a - 1.0) * rand2));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
	
	vec3 H_tangent = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
	
	vec3 tangent, bitangent;
	createOrthonormalBasis(N, tangent, bitangent);
	vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
	
	vec3 L = reflect(-V, H);
	return L;
}

vec3 sampleGGX_HalfVector(vec3 N, float roughness, float rand1, float rand2) {
    float a = roughness * roughness;
    float phi = 2.0 * pi * rand1;

    float cosTheta = sqrt((1.0 - rand2) / (1.0 + (a * a - 1.0) * rand2));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    vec3 H_tangent = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    vec3 tangent, bitangent;
    createOrthonormalBasis(N, tangent, bitangent);

    return normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
}

float pdfGGX(in vec3 N, in vec3 H, in vec3 V, float roughness) {
	float NdotH = max(dot(N, H), 0.0);
	float VdotH = max(dot(V, H), 0.0);
	float D = DistributionGGX(NdotH, roughness);
	return (D * NdotH) / (4.0 * VdotH + 0.0001);
}





vec3 path_trace_diffuse(in vec2 uv, in RaycastHit hit, in int max_bounces) {
	vec3 radiance = vec3(0.0);
	int bounces = max_bounces;
	vec3 shot_loc = camera_loc;

	while(bounces > 0) {
		vec3 V = normalize(shot_loc - hit.location);
		vec3 N = hit.normal;
		if (dot(V, N) < 0.0) {
			N = -N;
		}

		float rand1 = random(uv + fract(hit.location.zx) + vec2(0.6524222, 0.685732));
		float rand2 = random(uv + fract(hit.location.yx) + vec2(0.5411499, 0.317767));
		
		vec3 diffSampleDir = sampleCosineWeightedDirection(N, rand1, rand2);
		
		float pdf_d = pdfDiffuse(N, diffSampleDir);
		
		vec3 diffuseTerm = lambertianBRDF(principled_bsdfs[hit.material_index].albedo);
		
		vec3 sampleDiffuseContribution = (diffuseTerm * max(dot(N, diffSampleDir), 0.0)) / max(pdf_d, 0.0001);



		radiance += sampleDiffuseContribution;

		shot_loc = hit.location;
		hit = raycast(hit.location, diffSampleDir);

		bounces--;
	}

	return radiance;
}

vec3 path_trace_glossy(in vec2 uv, in RaycastHit hit, in int max_bounces) {
	vec3 radiance = vec3(0.0);
	int bounces = max_bounces;
	vec3 shot_loc = camera_loc;

	while(bounces > 0) {
		vec3 V = normalize(shot_loc - hit.location);
		vec3 N = hit.normal;
		if (dot(V, N) < 0.0) {
			N = -N;
		}

		float roughness = principled_bsdfs[hit.material_index].roughness;
		vec3 F0 = mix(vec3(0.04), vec3(principled_bsdfs[hit.material_index].reflectance), principled_bsdfs[hit.material_index].metallic);
		
		float rand1 = random(uv + fract(hit.location.xy) + vec2(0.431441, 0.69992111));
		float rand2 = random(uv + fract(hit.location.yz) + vec2(0.765221, 0.86754333));
		
		vec3 L = sampleGGXDirection(N, V, roughness, rand1, rand2);
		
		vec3 H = normalize(V + L);
		
		float pdf = pdfGGX(N, H, V, roughness);
		
		vec3 specular = cookTorranceBRDF(N, V, L, roughness, F0);
		
		float cosTheta = max(dot(N, L), 0.0);
		
		vec3 sampleContribution = (specular * cosTheta) / max(pdf, 0.0001);



		radiance += sampleContribution;

		shot_loc = hit.location;
		hit = raycast(hit.location, L);

		bounces--;
	}

	return radiance;
}

vec3 path_trace(in vec2 uv, in RaycastHit first_hit, in int max_bounces) {
	vec3 throughput = vec3(1.0);
	vec3 radiance = vec3(0.0);
	
	RaycastHit hit = first_hit;
	for (int bounce = max_bounces; bounce > 0; bounce--) {
		if (hit.hit) {
			PrincipledBSDF material = principled_bsdfs[hit.material_index];

			vec3 V = -hit.direction;
			vec3 N = hit.normal;

			vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);
			float NdotV = max(dot(N, V), 0.0);
			vec3 F = fresnelSchlick(NdotV, F0);



			if ((material.emissive.x + material.emissive.y + material.emissive.z) * material.emissive.w > 0.001) {
				radiance += throughput * vec3(material.emissive) * material.emissive.w;
				break;
			}

            bool isDelta = material.metallic > 0.0 || material.transmission > 0.0 && material.roughness < 0.01;
			if (!isDelta) {
				for (uint i = 0; i < point_lights_no; i++) {
					vec3 L = point_lights[i].location - hit.location;
					float light_dist = length(L);
					L = normalize(L);
					
					RaycastHit shadow_hit = raycast(hit.location, L);
					if (!shadow_hit.hit || distance(hit.location, shadow_hit.location) > light_dist) {
						float cosNL = max(dot(N, L), 0.0);

						float light_attenuation = 1.0 / (light_dist * light_dist);
						
						vec3 kS = F;
						vec3 kD = vec3(1.0) - kS;
						kD *= (1.0 - material.metallic);
						
						vec3 diffuse  = lambertianBRDF(material.albedo);
						vec3 specular = cookTorranceBRDF(N, V, L, material.roughness, F0);
						vec3 fullBRDF = kD * diffuse + specular;
						
						vec3 light_radiance = point_lights[i].color * point_lights[i].intensity;
						
						radiance += throughput * fullBRDF * light_radiance * cosNL * light_attenuation;
					}
				}
			}



			vec3 newDir;
            float pdf;
            vec3 brdfValue;

			if (material.transmission > 0.0) {
				if (material.roughness < 0.01) {
					float cosTheta = dot(V, N);
					float eta = cosTheta > 0.0 ? (1.0 / material.ior) : material.ior;
					vec3 reflDir = reflectRay(hit).direction;
					vec3 refrDir = refractRay(hit, material.ior).direction;
					
					// Schlick's approximation for reflectance
					float R0 = pow((1.0 - material.ior) / (1.0 + material.ior), 2.0);
					float reflectance = R0 + (1.0 - R0) * pow(1.0 - abs(cosTheta), 5.0);
					
					float rand = random(uv + fract(hit.location.zy) + vec2(0.123599, 0.541311));
					if (rand < reflectance) {
						newDir = reflDir;
						hit = raycast(hit.location, newDir);
					}
					else {
						newDir = refrDir;
						hit = raycast_transmissive(hit.location, newDir, hit.obj_type, hit.obj_index);
					}
				}
				else {
                    float u1 = random(uv + fract(hit.location.xy) + vec2(0.431441, 0.69992111));
					float u2 = random(uv + fract(hit.location.yz) + vec2(0.765221, 0.86754333));

                    vec3 H = sampleGGX_HalfVector(N, material.roughness, u1, u2);
                    float NdotH = max(dot(N, H), 0.0);

                    float VdotH = max(dot(V, H), 0.0);
                    float Fi = 0.04 + (1.0 - 0.04) * pow(1.0 - VdotH, 5.0);
                    
					float rand = random(uv + fract(hit.location.yz) + vec2(0.213111, 0.5416666));
                    if (rand < Fi) {
                        newDir = reflectRay(hit, H).direction;
                        float D = DistributionGGX(NdotH, material.roughness);
                        pdf = (D * NdotH) / (4.0 * max(dot(newDir, H), 0.0001));
                        float G = GeometrySmith(N, V, newDir, material.roughness);
                        brdfValue = (D * G * vec3(F)) / (4.0 * NdotV * max(dot(N, newDir), 0.0) + 0.0001);

						hit = raycast(hit.location, newDir);
                    }
					else {
                        float eta = dot(V, N) > 0.0 ? (1.0 / material.ior) : material.ior;
                        newDir = refractRay(hit, material.ior).direction;

                        if(length(newDir) < 0.001) {
							newDir = reflectRay(hit, H).direction;
							hit = raycast(hit.location, newDir);
						}
						else {
							hit = raycast_transmissive(hit.location, newDir, hit.obj_type, hit.obj_index);
						}
                        
                        float D = DistributionGGX(NdotH, material.roughness);
                        pdf = (D * NdotH) / (4.0 * abs(dot(newDir, H)) + 0.0001);
                        float G = GeometrySmith(N, V, newDir, material.roughness);
                        float denom = (NdotV + eta * max(dot(N, newDir), 0.0));
                        denom = denom * denom + 0.0001;
                        brdfValue = (vec3(1.0) - vec3(F)) * (eta * eta) * abs(dot(newDir, H)) * D * G / denom;
                    }

                    float cosine = max(dot(N, newDir), 0.0);
                    throughput *= (brdfValue * cosine) / max(pdf, 0.0001);
				}
			}
			else {
				float specProb = clamp((F.x + F.y + F.z) / 3.0, 0.0, 1.0);
				//float specProb = clamp((F.x + F.y + F.z) / 3.0 + 1.0 - material.roughness, 0.0, 1.0);
			
				float rChoice = random(uv + fract(hit.location.zx) + vec2(0.541233, 0.991198));
				if (rChoice < specProb) {
					float u1 = random(uv + fract(hit.location.xy) + vec2(0.431441, 0.69992111));
					float u2 = random(uv + fract(hit.location.yz) + vec2(0.765221, 0.86754333));

					newDir = sampleGGXDirection(N, V, material.roughness, u1, u2);
					vec3 H = normalize(V + newDir);

					pdf = pdfGGX(N, H, V, material.roughness);
					brdfValue = cookTorranceBRDF(N, V, newDir, material.roughness, F0);
				}
				else {
					float u1 = random(uv + fract(hit.location.zx) + vec2(0.6524222, 0.685732));
					float u2 = random(uv + fract(hit.location.yx) + vec2(0.5411499, 0.317767));

					newDir = sampleCosineWeightedDirection(N, u1, u2);

					pdf = pdfDiffuse(N, newDir);
					brdfValue = lambertianBRDF(material.albedo);
				}
				
				float cosine = max(dot(N, newDir), 0.0);
				throughput *= (brdfValue * cosine) / max(pdf, 0.0001);

				hit = raycast(hit.location, newDir);
			}

			// Russian roulette
			if (bounce > 2) {
				float survivalProb = max(throughput.r, max(throughput.g, throughput.b));
				float rProb = random(uv + fract(hit.location.xz) + vec2(0.431551, 0.1234889));
				if (rProb > survivalProb) {
					break;
				}
				throughput /= survivalProb;
			}
		}
		else {
			vec3 unitDir = normalize(hit.direction);
			float t = 0.5 * (unitDir.y + 1.0);
			vec3 envColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
			radiance += throughput * envColor;
			break;
		}
	}

	return radiance;
}



void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(tile_offset);
	vec2 uv = vec2(pixel_coords) / vec2(imageSize(img_output));

	if (scene_change == 1) {
		imageStore(img_output, pixel_coords, vec4(vec3(0.0), 1.0));
		return;
	}



	int ray_index = pixel_coords.y * imageSize(img_output).x + pixel_coords.x;

	float ndcX = uv.x * 2.0 - 1.0;
	float ndcY = 1.0 - uv.y * 2.0;

	vec4 clipSpace = vec4(ndcX, ndcY, 0.0, 1.0);
	vec4 viewSpace = inverse(camera_proj) * clipSpace;
	viewSpace.xyz /= viewSpace.w;
	vec4 worldSpace = inverse(camera_view) * viewSpace;
	worldSpace.xyz /= worldSpace.w;

	vec3 ray_loc = camera_loc;
	vec3 ray_dir = normalize(worldSpace.xyz - camera_loc);
	vec3 ray_color = vec3(0.0);

	//imageStore(img_output, pixel_coords, vec4(abs(ray_dir.x) * (ray_dir.x > 0.0 ? red : neg(red)), 1.0));



	const int max_bounces = 5;
	//const int max_diffuse_bounces = 4;
	//const int max_glossy_bounces  = 4;

	RaycastHit hit = raycast(ray_loc, ray_dir);
	ray_color = path_trace(uv, hit, max_bounces);

	/*
	if (hit.hit) {
		PrincipledBSDF material = principled_bsdfs[hit.material_index];

		if (material.transmission < 0.01) {
			for (int i = 0; i < point_lights_no; i++) {
				float r = point_lights[i].radius * 3.0;
				float att = max(0.0, r - distance(hit.location, point_lights[i].location)) / r;
				vec3 light = point_lights[i].intensity * point_lights[i].color * att;
				ray_color += material.albedo * light;
			}
		}
		else {
			hit = raycast_transmissive(hit.location, refractRay(hit, material.ior).direction, hit.obj_type, hit.obj_index);
			if (hit.hit) {
				hit = raycast(hit.location, refractRay(hit, material.ior).direction);
				if (hit.hit) {
					material = principled_bsdfs[hit.material_index];

					for (int i = 0; i < point_lights_no; i++) {
						float r = point_lights[i].radius * 3.0;
						float att = max(0.0, r - distance(hit.location, point_lights[i].location)) / r;
						vec3 light = point_lights[i].intensity * point_lights[i].color * att;
						ray_color = material.albedo * light;
					}
				}
			}
		}
	}
	ray_color /= 100.0;
	*/

	/*
	if (hit.hit == true) {
		ray_color *= path_trace_diffuse(uv, hit, max_diffuse_bounces);
		ray_color *= path_trace_glossy(uv, hit, max_glossy_bounces);
	}
	*/

	ray_color = max(ray_color, 0.0);



	vec3 currect_pixel = max(imageLoad(img_output, pixel_coords).xyz, 0.0);
	vec4 final_color = vec4((currect_pixel + ray_color), 1.0);
	imageStore(img_output, pixel_coords, final_color);


	//imageStore(img_output, pixel_coords, texture(blueNoise, uv));
}
