
vec3 rgb2hsv(vec3 color) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(color.bg, K.wz), vec4(color.gb, K.xy), step(color.b, color.g));
    vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv2rgb(vec3 color) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);
    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);
}

vec3 hueShift(vec3 color, float hue) {
    vec3 hsv = rgb2hsv(color);
    hsv.x = mod(hsv.x + hue / 360.0, 1.0);
    return hsv2rgb(hsv);
}
vec3 saturationMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.y *= factor;
    return hsv2rgb(hsv);
}
vec3 valueMul(vec3 color, float factor) {
    vec3 hsv = rgb2hsv(color);
    hsv.z *= factor;
    return hsv2rgb(hsv);
}


vec3 tangent(vec3 v) {
	vec3 arbx = vec3(1.0, 0.0, 0.0);
	vec3 arby = vec3(0.0, 1.0, 0.0);
	vec3 arbz = vec3(0.0, 0.0, 1.0);

	vec3 arbitrary = arbx;
	if (abs(dot(v, arby)) < abs(dot(v, arbitrary))) {
		arbitrary = arby;
	}
	if (abs(dot(v, arbz)) < abs(dot(v, arbitrary))) {
		arbitrary = arbz;
	}

	return normalize(cross(v, arbitrary));
}

float angle(vec3 a, vec3 b) {
	return acos(dot(a, b) / (length(a) * length(b)));
}


/*
mat3 rotationMatrix(float angleX, float angleY, float angleZ) {
	float radX = radians(angleX);
	float radY = radians(angleY);
	float radZ = radians(angleZ);

	mat3 rotX = mat3(1.0, 0.0, 0.0,
					 0.0, cos(radX), -sin(radX),
					 0.0, sin(radX), cos(radX));

	mat3 rotY = mat3(cos(radY), 0.0, sin(radY),
					 0.0, 1.0, 0.0,
					 -sin(radY), 0.0, cos(radY));

	mat3 rotZ = mat3(cos(radZ), -sin(radZ), 0.0,
					 sin(radZ), cos(radZ), 0.0,
					 0.0, 0.0, 1.0);

	return rotZ * rotY * rotX;
}
float random(vec2 v, int seed) {
	return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123 * seed);
}
vec3 rotateVectorRandom(vec3 v, int seed, float maxAngle) {
	float randomAngleX = random(v.xy, seed) * maxAngle;
	float randomAngleY = random(v.yz, seed) * maxAngle;
	float randomAngleZ = random(v.zx, seed) * maxAngle;

	mat3 rotMatrix = rotationMatrix(randomAngleX, randomAngleY, randomAngleZ);
	vec3 rotatedVec = rotMatrix * v;

	return rotatedVec;
}
*/
float random(float value) {
	return fract(sqrt(value * 129.898) + 100.001 / 7.69 * 43758.5453);
}
vec3 rotateVector(vec3 v, vec3 axis, float angle) {
	// Rodrigues' rotation formula
	return mix(dot(axis, v) * axis, v, cos(angle)) + cross(axis, v) * sin(angle);
}
vec3 diffuseVector(vec3 v, vec3 normal, float maxAngle) {
	float randomAngleX = random(dot(v, normal) * maxAngle + 12.68) * maxAngle - maxAngle / 2.0;
	float randomAngleY = random(dot(v, normal) * maxAngle + 41.01) * maxAngle - maxAngle / 2.0;
	float randomAngleZ = random(dot(v, normal) * maxAngle + 65.32) * maxAngle - maxAngle / 2.0;

	vec3 tg = tangent(normal);

	vec3 rotZ = rotateVector(v, normal, randomAngleZ);
	vec3 rotY = rotateVector(rotZ, tg, randomAngleY);
	vec3 rotX = rotateVector(rotY, normalize(cross(normal, tg)), randomAngleX);

	return normalize(mix(normal, rotX, 0.66));
}


uint packColor(vec4 color) {
	return uint(color.r * 255.0) << 24 |
		   uint(color.g * 255.0) << 16 |
		   uint(color.b * 255.0) <<  8 |
		   uint(color.a * 255.0);
}
vec4 unpackColor(uint packedColor) {
	return vec4(
		float((packedColor >> 24) & 0xFF) / 255.0,
		float((packedColor >> 16) & 0xFF) / 255.0,
		float((packedColor >>  8) & 0xFF) / 255.0,
		float( packedColor        & 0xFF) / 255.0
	);
}


float mulAdd(float a, float b) {
	return fma(a, b, a);
}
