vec3 trace(Ray ray, inout vec2 seed) {
    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);
    vec3 newDir, brdfValue;
    float pdf = 1.0;
    
    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {
        HitRecord rec;
        if (hitScene(ray, rec)) {
            // Add emission if present.
            if (length(rec.material.emission) > 0.001)
                radiance += throughput * rec.material.emission;
            
            // Next Event Estimation (for non-delta surfaces).
            // Here we assume delta behavior for ideal specular surfaces.
            bool isDelta = false;
            // For this example, we treat materials as delta if they are transmissive
            // and have near-zero roughness or if they are metallic.
            if ((rec.material.transmissive && rec.material.roughness < 0.01) ||
                (rec.material.metallic > 0.99)) {
                isDelta = true;
            }
            
            if (!isDelta) {
                vec3 L_dir = normalize(lightPos - rec.point);
                float lightDist = length(lightPos - rec.point);
                Ray shadowRay;
                shadowRay.origin = rec.point + rec.normal * EPSILON;
                shadowRay.direction = L_dir;
                bool occluded = false;
                HitRecord shadowRec;
                if (hitScene(shadowRay, shadowRec)) {
                    if (shadowRec.t < lightDist)
                        occluded = true;
                }
                if (!occluded) {
                    float cosNL = max(dot(rec.normal, L_dir), 0.0);
                    float lightAtt = 1.0 / (lightDist * lightDist);
                    vec3 V = -ray.direction;
                    vec3 F0 = mix(vec3(0.04), rec.material.albedo, rec.material.metallic);
                    vec3 F = fresnelSchlick(max(dot(rec.normal, V), 0.0), F0);
                    vec3 kS = F;
                    vec3 kD = vec3(1.0) - kS;
                    kD *= (1.0 - rec.material.metallic);
                    vec3 diffuse = lambertianBRDF(rec.material.albedo);
                    vec3 specular = cookTorranceBRDF(rec.normal, V, L_dir, rec.material.roughness, F0);
                    vec3 fullBRDF = kD * diffuse + specular;
                    vec3 lightRad = lightColor * lightIntensity;
                    radiance += throughput * fullBRDF * lightRad * cosNL * lightAtt;
                }
            }
            
            // --- SCATTERING / BOUNCE ---
            // If the material is marked as transmissive, treat it as glass.
            if (rec.material.transmissive) {
                // If the material is ideally smooth, use delta (perfect) transmission/reflection.
                if (rec.material.roughness < 0.01) {
                    float cosTheta = dot(-ray.direction, rec.normal);
                    bool entering = cosTheta > 0.0;
                    float eta = entering ? (1.0 / rec.material.refractiveIndex) : rec.material.refractiveIndex;
                    vec3 reflDir = reflect(ray.direction, rec.normal);
                    vec3 refrDir = refract(ray.direction, rec.normal, eta);
                    // Schlick's Fresnel approximation.
                    float R0 = pow((1.0 - rec.material.refractiveIndex) / (1.0 + rec.material.refractiveIndex), 2.0);
                    float reflectance = R0 + (1.0 - R0) * pow(1.0 - abs(cosTheta), 5.0);
                    newDir = (rand(seed) < reflectance) ? reflDir : refrDir;
                    pdf = 1.0;
                    brdfValue = vec3(1.0); // Delta handling.
                    // For delta materials, the cosine factor is handled implicitly.
                    throughput *= 1.0;
                } else {
                    // For rough transmissive (glass) materials, you could implement a rough-transmission
                    // model (e.g., using a microfacet model for transmission). For simplicity, we use
                    // a hybrid approach similar to the specular branch.
                    float u1 = rand(seed);
                    float u2 = rand(seed);
                    // Sample a half-vector from a GGX distribution.
                    vec3 H = sampleCosX_HalfVector(rec.normal, rec.material.roughness, u1, u2);
                    // Compute the Fresnel term (we use a fixed F0 of 0.04 for dielectrics).
                    float dotVH = max(dot(-ray.direction, H), 0.0);
                    float F = 0.04 + (1.0 - 0.04) * pow(1.0 - dotVH, 5.0);
                    if (rand(seed) < F) {
                        // Reflection branch.
                        newDir = reflect(ray.direction, H);
                        float D = DistributionGGX(max(dot(rec.normal, H), 0.0), rec.material.roughness);
                        pdf = (D * max(dot(rec.normal, H), 0.0)) / (4.0 * max(dot(newDir, H), 1e-4));
                        float G = GeometrySmith(rec.normal, -ray.direction, newDir, rec.material.roughness);
                        brdfValue = (D * G * vec3(F)) / (4.0 * max(dot(rec.normal, -ray.direction), 0.0) * max(dot(rec.normal, newDir), 0.0) + 1e-4);
                    } else {
                        // Transmission branch.
                        bool entering = dot(-ray.direction, rec.normal) > 0.0;
                        float eta = entering ? (1.0 / rec.material.refractiveIndex) : rec.material.refractiveIndex;
                        newDir = refract(ray.direction, rec.normal, eta);
                        if(length(newDir) < 1e-3)
                            newDir = reflect(ray.direction, rec.normal);
                        float D = DistributionGGX(max(dot(rec.normal, H), 0.0), rec.material.roughness);
                        pdf = (D * max(dot(rec.normal, H), 0.0)) / (4.0 * abs(dot(newDir, H)) + 1e-4);
                        float G = GeometrySmith(rec.normal, -ray.direction, newDir, rec.material.roughness);
                        float denom = (max(dot(rec.normal, -ray.direction), 0.0) + eta * max(dot(rec.normal, newDir), 0.0));
                        denom = denom * denom + 1e-4;
                        brdfValue = (vec3(1.0) - vec3(F)) * (eta * eta) * abs(dot(newDir, H)) * D * G / denom;
                    }
                    float cosine = max(dot(rec.normal, newDir), 0.0);
                    throughput *= (brdfValue * cosine) / max(pdf, 1e-4);
                }
            } else {
                // Non-transmissive branch: for metallic or diffuse surfaces.
                vec3 V = -ray.direction;
                vec3 F0 = mix(vec3(0.04), rec.material.albedo, rec.material.metallic);
                float NdotV = max(dot(rec.normal, V), 0.0);
                vec3 F = fresnelSchlick(NdotV, F0);
                float specProb = clamp((F.r + F.g + F.b) / 3.0, 0.0, 1.0);
                float rChoice = rand(seed);
                if (rChoice < specProb) {
                    float u1 = rand(seed);
                    float u2 = rand(seed);
                    newDir = sampleGGXDirection(rec.normal, V, rec.material.roughness, u1, u2);
                    vec3 H = normalize(V + newDir);
                    pdf = pdfGGX(rec.normal, H, V, rec.material.roughness);
                    brdfValue = cookTorranceBRDF(rec.normal, V, newDir, rec.material.roughness, F0);
                } else {
                    float u1 = rand(seed);
                    float u2 = rand(seed);
                    newDir = sampleCosineWeightedDirection(rec.normal, u1, u2);
                    pdf = pdfDiffuse(rec.normal, newDir);
                    brdfValue = lambertianBRDF(rec.material.albedo);
                }
                float cosine = max(dot(rec.normal, newDir), 0.0);
                throughput *= (brdfValue * cosine) / max(pdf, 1e-4);
            }
            
            // Russian roulette termination.
            if (bounce > 2) {
                float survivalProb = max(throughput.r, max(throughput.g, throughput.b));
                if (rand(seed) > survivalProb)
                    break;
                throughput /= survivalProb;
            }
            
            ray.origin = rec.point + newDir * EPSILON;
            ray.direction = newDir;
        } else {
            // Environment (sky) gradient.
            vec3 unitDir = normalize(ray.direction);
            float t = 0.5 * (unitDir.y + 1.0);
            vec3 envColor = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
            radiance += throughput * envColor;
            break;
        }
    }
    return radiance;
}